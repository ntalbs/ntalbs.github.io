<!DOCTYPE html><html><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-2098194-3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-2098194-3');</script><meta charset="utf-8"><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta name="viewport" content="width=device-width,initial-scale=1"><title>프로젝트 오일러 54 @ntalbs' stuff</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"></head><body><div id="progress"><div id="bar"></div><div class="container"><div id="scroll-title">프로젝트 오일러 54</div></div></div><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button>
<a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archive/">Archive</a></li><li><a href="/tags/">Tags</a></li><li><a href="/about/">About</a></li></ul></div></div></nav><header class="page-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header><p class="post-meta"><time datetime="2016-03-08" itemprop="datePublished">2016-03-08</time>
on
<a href="/tags/project-euler/">Project-Euler</a>
<a href="/tags/clojure/">Clojure</a></p><h1 class="post-title">프로젝트 오일러 54</h1></header><section class="post-content"><blockquote><p>포커 게임에서 이긴 회수 구하기</p><p>문제 자세히 보기: <a href="http://euler.synap.co.kr/prob_detail.php?id=54">[국어]</a> <a href="https://projecteuler.net/problem=54">[영어]</a></p></blockquote><p>이 문제를 푸는 데 수학적인 지식이나 통찰은 전혀 필요하지 않은 것으로 보였다. 그저 주어진 카드 패가 어떤 계급인지 판단하는 방법을 구현하고 계급에 따라 승패를 정해 1번 선수가 이긴 횟수를 구하기만 하면 되는 단순한 문제로 보였다. 이렇게 해도 답을 구하는 데는 전혀 문제가 없었지만, 마음에 들지 않았다. 패가 특정 계급인지 판단하는 여러 개의 함수와 연속된 조건문... 더 좋은 방법이 없을까?</p><p>그러다 <a href="http://blog.dreamshire.com/project-euler-54-solution/">Dreamshire</a>에서 새로운 풀이를 보게 되었다. 패를 정량화할 수 있다면 빠르게 승패를 알 수 있다. 계급의 순서는 문제에 주어졌다. 스트레이트와 플러시(스트레이트 플러시와 로열 플러시 포함)를 제외한 다른 패는 모두 같은 숫자가 몇 개인지에 따라 계급이 결정된다. 스트레이트와 플러시 계열은 별도 절차를 통해 확인해야 한다.</p><p>먼저 카드의 숫자를 진짜 숫자로 바꾸는 함수가 있어야 한다. 카드 숫자 중 일부가 알파벳으로 되어 있으므로 이를 숫자로 바꿔 놓아야 정렬하기가 쉽다.</p><pre><code class="language-clojure hljs">(defn n-&gt;p <span class="hljs-string">"Convert number on card to point"</span> [c]
  (case c
    \<span class="hljs-number">2</span> <span class="hljs-number">2</span>, \<span class="hljs-number">3</span> <span class="hljs-number">3</span>, \<span class="hljs-number">4</span> <span class="hljs-number">4</span>, \<span class="hljs-number">5</span> <span class="hljs-number">5</span>, \<span class="hljs-number">6</span> <span class="hljs-number">6</span>, \<span class="hljs-number">7</span> <span class="hljs-number">7</span>, \<span class="hljs-number">8</span> <span class="hljs-number">8</span>, \<span class="hljs-number">9</span> <span class="hljs-number">9</span>,
    \T <span class="hljs-number">10</span>, \J <span class="hljs-number">11</span>, \Q <span class="hljs-number">12</span>, \K <span class="hljs-number">13</span>, \A <span class="hljs-number">14</span>))
</code></pre><p>패가 스트레이트인지 확인하는 함수와 플러시인지 확인하는 다음과 같이 작성할 수 있다.</p><pre><code class="language-clojure hljs">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> straight-set
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> <span class="hljs-string">"A23456789TJQKA"</span>
       (<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>)
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> set)
       set))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> straight? [hand]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [card-nums (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> hand (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> first) set)]
    (<span class="hljs-name"><span class="hljs-builtin-name">contains?</span></span> straight-set (<span class="hljs-name">set</span> card-nums))))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> flush? [hand]
  (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> hand (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> second) set count)))
</code></pre><p>카드 숫자를 정렬해 파티션한 다음 각 파티션의 원소 수를 나타낸 패턴을 구하면 그 패턴으로 계급을 알 수 있다.</p><pre><code class="hljs">[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>] =&gt; high card
[<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]   =&gt; one pair
[<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]     =&gt; two pairs
[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]     =&gt; threee of a kind
[]          =&gt; straight
[]          =&gt; flush
[<span class="hljs-number">3</span> <span class="hljs-number">2</span>]       =&gt; full house
[<span class="hljs-number">4</span> <span class="hljs-number">1</span>]       =&gt; four of a kind
</code></pre><p>플러시인 동시에 스트레이트면 스트레이트 플러시가 되고, 스트레이트 플러이인데 카드 숫자가 10, J, Q, K, A면 로열 플러시다. 이 사실을 이용해 패의 계급을 구하는 함수는 다음과 같이 작성할 수 있다.</p><pre><code class="language-clojure hljs">(<span class="hljs-name">defn</span> rank [<span class="hljs-name">hand</span>]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [<span class="hljs-name">ranks</span> [[<span class="hljs-name">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>] [<span class="hljs-name">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>] [<span class="hljs-name">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>] [<span class="hljs-name">3</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>] [] [] [<span class="hljs-name">3</span> <span class="hljs-number">2</span>] [<span class="hljs-name">4</span> <span class="hljs-number">1</span>]]
        nums   (<span class="hljs-name">-&gt;&gt;</span> hand (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> first) (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> n-&gt;p) (<span class="hljs-name">sort</span> desc) (<span class="hljs-name">partition-by</span> identity))
        r1     (<span class="hljs-name">-&gt;&gt;</span> nums (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> count) (<span class="hljs-name">sort</span> desc) (<span class="hljs-name">.indexOf</span> ranks))
        r2     (<span class="hljs-name">-&gt;&gt;</span> nums (<span class="hljs-name">sort-by</span> count desc) (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> first) vec)
        str?   (<span class="hljs-name">straight?</span> hand)
        flush? (<span class="hljs-name">flush?</span> hand)]
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
      (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> flush? (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> r2 [<span class="hljs-name">14</span> <span class="hljs-number">13</span> <span class="hljs-number">12</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span>])) [<span class="hljs-name">9</span> r2]   <span class="hljs-comment">; royal straight flush</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> flush? str?) [<span class="hljs-name">8</span>  r2]                     <span class="hljs-comment">; straight flush</span>
      flush?            [<span class="hljs-name">5</span>  r2]                     <span class="hljs-comment">; flush</span>
      str?              [<span class="hljs-name">4</span>  r2]                     <span class="hljs-comment">; straight</span>
      :else             [<span class="hljs-name">r1</span> r2])))
</code></pre><p><code>sort</code>와 <code>sort-by</code> 함수는 비교 함수를 따로 지정하지 않으면 <code>compare</code> 함수를 사용해 정렬한다. 내림차순으로 정렬하기 위해서는 비교 함수를 따로 전달해야 한다. 위에서 사용한 <code>desc</code> 함수는 다음과 같이 작성하면 된다. <code>compare</code>의 인자 순서만 바꿔주면 정렬 순서가 반대로 될 것이다.</p><pre><code class="language-clojure hljs">(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> desc [x y] (<span class="hljs-name"><span class="hljs-builtin-name">compare</span></span> y x))
</code></pre><p>위 <code>rank</code> 함수는 패의 계급뿐 아니라 패의 숫자도 함께 리턴한다. 패의 계급이 같을 때는 패의 숫자를 비교해 승패를 가리기 위해서다. 패의 숫자는 패의 계급을 결정하는 숫자가 먼저 나오고 나머지 숫자는 그냥 내림차순으로 나오면 된다. 즉 패의 숫자가 5, 5, 8, 9, 10이라면 5가 두 개 있으므로 계급은 one pair가 되고 5가 계급을 결정하는 숫자가 될 것이다. 따라서 <code>rank</code> 함수는 <code>[5 10 9 8]</code>을 함께 리턴하게 된다.</p><p>게임 파일을 읽어 각 선수별로 패를 저장해 놓으면 문제를 푸는 데 도움이 될 것이다. 다음은 <code>games</code>에 각 게임을 <code>{:p1 ("8C" "TS" "KC" "9H" "4S"), :p2 ("7D" "2S" "5D" "3S" "AC")}</code> 형식의 시퀀스로 저정한다. <code>:p1</code>은 1번 선수, <code>:p2</code>는 2번 선수를 뜻한다.</p><pre><code class="language-clojure hljs">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> games
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name">clojure.string/split</span> (<span class="hljs-name"><span class="hljs-builtin-name">slurp</span></span> <span class="hljs-string">"data/poker.txt"</span>) #<span class="hljs-string">"\r\n"</span>)
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> #(<span class="hljs-name">clojure.string/split</span> % #<span class="hljs-string">" "</span>))
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [g] {<span class="hljs-symbol">:p1</span> (<span class="hljs-name"><span class="hljs-builtin-name">take</span></span> <span class="hljs-number">5</span> g) <span class="hljs-symbol">:p2</span> (<span class="hljs-name"><span class="hljs-builtin-name">drop</span></span> <span class="hljs-number">5</span> g)}))))
</code></pre><p>이제 1번 선수가 이긴 횟수만 구하면 된다. 다행히 Clojure의 <code>compare</code> 함수는 <code>rank</code>가 리턴한 결과도 비교할 수 있다. 두 선수의 계급을 <code>compare</code>로 비교해 결과가 양수인 것만 세면 답을 구할 수 있다.</p><pre><code class="language-clojure hljs">(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> solve []
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> games
       (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">compare</span></span> (<span class="hljs-name">rank</span> (<span class="hljs-symbol">:p1</span> %)) (<span class="hljs-name">rank</span> (<span class="hljs-symbol">:p2</span> %))))
       (<span class="hljs-name"><span class="hljs-builtin-name">filter</span></span> pos?)
       count))
</code></pre><p>실행 결과는 다음과 같다.</p><pre class="console">p054=&gt; (time (solve))
"Elapsed time: 32.488653 msecs"
3?6
</pre><p>예전 방식과 비교해 라인 수도 절반 이하로 줄었고, 코드도 훨씬 아름다워 졌다.</p><h2 id="참고">참고</h2><ul><li><a href="https://github.com/ntalbs/euler/blob/master/src/p054.clj">프로젝트 오일러 54 풀이 소스 코드</a>
<a href="http://blog.dreamshire.com/project-euler-54-solution/">Dreamshire</a>의 풀이를 참고해 다시 작성한 코드.</li><li><a href="https://github.com/ntalbs/euler/blob/3007c3ba398efc2cee7e0c11e07b07f353db68f2/src%2Fp054.clj">프로젝드 오일러 54 풀이 소스 (기존 버전) 코드</a>
처음 풀이. 새 풀이와 비교해 코드가 훨씬 길 뿐 아니라 아름답지도 않다.</li><li><a href="http://blog.dreamshire.com/project-euler-54-solution/">Dreamshire &gt; Project Euler 54 Solution</a></li></ul></section><footer class="post-footer"><div class="social button-box"><a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a>
<a class="twitter-follow-button" href="https://twitter.com/ntalbs" data-show-count="false">Follow @ntalbs</a>
<script async="" src="//platform.twitter.com/widgets.js"></script></div><nav id="article-nav"><a class="article-nav-link-wrap previous" href="https://ntalbs.github.io/2016/project-euler-055/" id="article-nav-newer">프로젝트 오일러 55</a>
<a class="article-nav-link-wrap next" href="https://ntalbs.github.io/2016/opening-uk-bank-account/" id="article-nav-older">영국 은행 계좌 만들기</a></nav></footer></article></main><section class="section"><div class="container"><aside><div id="disqus_thread"></div></aside><script type="text/javascript">var disqus_shortname='ntalbs-stuff';(function(){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></section><section class="section"><div class="container has-text-centered"><p></p></div></section><script src="https://ntalbs.github.io/js/index.js" type="text/javascript"></script><link rel="stylesheet" href="/css/googlecode.css"><footer class="page-bottom"><div class="inner"><section class="copyright">© 2008-2019 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="https://gohugo.io">Hugo</a></section></div></footer>
</body></html>