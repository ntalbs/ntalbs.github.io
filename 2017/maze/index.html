<!DOCTYPE html><html><head><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>미로 생성 | ntalbs&#39; stuff</title><meta name="description" content=""><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="ntalbs' stuff"></head><body class="home-template"><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button> <a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archives">Archives</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></div></div></nav><div id="progress"><div id="bar"></div><div class="container"><div id="scroll-title">미로 생성</div></div></div><header class="site-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header><p class="post-meta"><time datetime="2017-09-19T23:00:00.000Z" itemprop="datePublished">2017-09-20</time> on <a href="/tags/JavaScript/" style="margin:0 5px">JavaScript</a><a href="/tags/알고리즘/" style="margin:0 5px">알고리즘</a></p><h1 class="post-title">미로 생성</h1></header><section class="post-content"><img src="/2017/maze/maze1.png" alt="maze1.png"><p>미로에서 길을 찾는 알고리즘은 비교적 쉽다. 길을 따라 가다가 갈림길이 나오면 해당 위치를 스택에 넣고 갈림길 중 한 쪽으로 계속해서 가면 된다. 막다른 길이면 스택에 넣었던 위치까지 돌아나와서 다른 갈림길로 계속 가면 된다. 이런 식으로 계속 탐색을 하다보면 길을 찾게 된다. 자료구조 시간에 배웠던 알고리즘이다. 그런데 미로를 생성하려면 어떻게 해야 할까?<br><a id="more"></a></p><p><a href="https://pragprog.com/book/jbmaze/mazes-for-programmers" target="_blank" rel="external">Mazes for Programmers</a>에 미로 생성 알고리즘이 잘 설명되어 있다. 미로 생성 알고리즘뿐 아니라 미로에 대한 거의 모든 것을 다룬 책이라 할 수 있다. 책에 나오는 미로 생성 알고리즘을 순서대로 몇 개만 나열해보면, Binary Tree, Sidewinder, Aldous-Broder, Willson’s, Hunt-and-Kill, Recursive Backtracker 등이 있으며, 알고리즘에 따라 생성되는 미로의 특성도 다르다.</p><img src="/2017/maze/maze2.png" alt="maze2.png"><p>저자의 블로그에서 <a href="http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap" target="_blank" rel="external">Maze Generation: Algorithm Recap</a>도 미로 생성 알고리즘을 이해하든 데 많은 도움이 된다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://pragprog.com/book/jbmaze/mazes-for-programmers" target="_blank" rel="external">Mazes for Programmers</a><br>미로 생성의 거의 모든 것을 다루는 책이다. 직사각형 모양의 기본 미로 생성 알고리즘부터 특정 모양의 미로를 만드는 방법, 육각형이나 원형 미로를 만드는 방법, 3차원 미로를 만드는 방법까지 다양한 주제를 다룬다.</li><li><a href="http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap" target="_blank" rel="external">Maze Generation: Algorithm Recap</a><br>웹 페이지에서 각 알고리즘이 미로를 생성하는 과정을 단계별로 실행시켜볼 수 있다. 미로 생성 알고리즘이 어떻게 동작하는지 이해하는 데 큰 도움이 된다.</li><li><a href="https://github.com/ntalbs/maze-js" target="_blank" rel="external">Maze-js</a><br>책의 코드를 JavaScript로 옮긴 개인 프로젝트. 지금은 거의 방치되어 있다.</li></ul></section><footer class="post-footer"><nav id="article-nav"><a href="/2017/alphago/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title">알파고</span> </a><a href="/2016/productivity/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">연습과 생산성</span></a></nav><section id="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></footer></article></main><footer class="site-footer"><div class="inner"><section class="copyright">&copy; 2008-2015 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="http://hexo.io">Hexo</a></section></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script type="text/javascript" src="/js/jquery.fitvids.js"></script><script type="text/javascript" src="/js/index.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>!function(e,a,t,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=a.createElement(t),o=a.getElementsByTagName(t)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-2098194-3","auto"),ga("require","displayfeatures"),ga("send","pageview")</script><script type="text/javascript">var disqus_shortname="ntalbs-stuff";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>