<!doctype html><html><head><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3882204692252974" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-2098194-3"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-2098194-3')</script><meta charset=utf-8><meta name=google-site-verification content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta property="og:image" content="https://ntalbs.github.io/images/ntalbs.jpg"><meta name=viewport content="width=device-width,initial-scale=1"><title>infix 매크로 @ntalbs' stuff</title><link rel="shortcut icon" href=/images/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/highlight.css></head><body><div id=progress><div id=bar></div><div class=container><div id=scroll-title>infix 매크로</div></div></div><nav class=navbar role=navigation><div class=container><div class=navbar-header><button type=button class="navbar-toggle unselectable" data-toggle=collapse data-target=#nav-items>+</button>
<a class="navbar-brand unselectable" href=/>@ntalbs' stuff</a></div><div class="navbar-items collapsed" id=nav-items><ul><li><a class=unselectable href=/archive/>Archive</a></li><li><a class=unselectable href=/tags/>Tags</a></li><li><a class=unselectable href=/about/>About</a></li><li><a id=mode-switch class=unselectable href=#></a></li></ul></div></div></nav><header class=page-head><div class=container><p class=blog-description>내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class=container role=main><article class=post><header><p class=post-meta><time datetime=2014-06-25 itemprop=datePublished>2014-06-25</time>
on
<a href=/tags/clojure/>Clojure</a></p><h1 class=post-title>infix 매크로</h1></header><section class=post-content><p><a href=/2014/clojure-fallacy/>Clojure에 대한 오해</a>에서 LISP 언어가 널리 사용되지 않는 주요 이유 중 하나로 <strong>전위 표기법</strong>(prefix notation)을 들었다. LISP의 표현력이 뛰어난 이유 중 하나가 전위 표기법 때문인데 이것 때문에 LISP이 널리 사용되지 못한다니 역설이 아닐 수 없다.</p><p>전위 표기법이 아무리 막강하다 해도 수식을 작성할 때는 불편하다. 전위 표기법에 웬만큼 익숙해졌다 싶은데도 수식을 입력할 때는 여전히 번거롭다. 그래서 중위 표기법(infix notation)으로 작성된 수식을 전위 표기법으로 전환해주는 매크로를 만들면 어떨까 생각했다. 사실 아직까지 매크로를 작성해본 적이 없어 약간 망설여지긴 했지만 한번 해보기로 했다.</p><p>일반적인 수식을 완벽하게 해석하기는 어려울 것 같아 다음과 같은 제약조건을 두기로 했다.</p><ul><li>괄호 안에는 한 가지 연산자만 들어갈 수 있다. 즉 <code>(1 + 2 + 3)</code>은 유효하지만 <code>(1 + 2 - 3)</code>은 유효하지 않다. 이 제약조건으로 연산자 우선순위 문제도 회피할 수 있다.</li><li>연산자와 피연산자 사이에는 반드시 공백이 있어야 한다.</li><li>일단 사칙연산만 지원한다. 즉 <code>+</code>, <code>-</code>, <code>-</code>, <code>/</code>만 사용할 수 있다.</li></ul><p>먼저 다음과 같이 주어진 수식이 유효한지 확인하는 함수를 만들었다. 리스트 안의 요소가 홀수개인지, 연산자 종류가 모두 같은지 확인한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn- </span><span class=nv>valid?</span> <span class=p>[</span><span class=nv>ops</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>and </span><span class=p>(</span><span class=nf>odd?</span> <span class=p>(</span><span class=nb>count </span><span class=nv>ops</span><span class=p>))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>-&gt;&gt;</span> <span class=nv>ops</span>
</span></span><span class=line><span class=cl>            <span class=nv>rest</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>take-nth </span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>apply </span><span class=nv>=</span><span class=p>))))</span>
</span></span></code></pre></div><p>그리고 다음과 같이 매크로를 작성했다. 처음 작성해보는 것이라 어렵지 않을까 생각했는데, 의외로 단순했다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defmacro </span><span class=nv>infix</span> <span class=p>[</span><span class=nv>ops</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nf>coll?</span> <span class=nv>ops</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nf>valid?</span> <span class=nv>ops</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>cons </span><span class=p>(</span><span class=nb>second </span><span class=nv>ops</span><span class=p>)</span> <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>take-nth </span><span class=mi>2</span> <span class=nv>ops</span><span class=p>)]</span> <span class=o>`</span><span class=p>(</span><span class=nf>infix</span> <span class=o>~</span><span class=nv>x</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>throw</span> <span class=p>(</span><span class=nf>Exception.</span> <span class=s>&#34;Invalid expression.&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nv>ops</span><span class=p>))</span>
</span></span></code></pre></div><p>인자가 컬렉션이 아니면 그대로 리턴한다. 컬렉션이면 유효한 수식인지 확인한다. 유효한 수식인 경우 인자의 두 번째 요소를 연산자로 뽑아내고 짝수번째 인자를 모두 뽑아 재귀적으로 자신을 다시 호출한다.</p><p>REPL에서 간단히 테스트해보니 잘 된다.</p><pre class=console>
user=> (use '[clojure.walk :only (macroexpand-all)])
nil
user=> (macroexpand-all '(infix (1 + 2)))
(+ 1 2)
user=> (macroexpand-all '(infix (1 + 2 + 3)))
(+ 1 2 3)
user=> (macroexpand-all '(infix ((n * (n + 1)) / 2)))
(/ (* n (+ n 1)) 2)
user=> (def n 15)
#'user/n
user=> (infix ((n * (n + 1)) / 2))
120
user=>
</pre><p>이제 <code>infix</code> 매크로를 사용해 수식을 알아보기 쉽게 작성할 수 있다. <code>n(n+1)/2</code>는 <code>(infix ((n * (n + 1)) / 2))</code>로 작성하면 된다. <code>(/ (* n (+ n 1)) 2)</code>보다 쓰기도 쉽고 읽기도 쉽다.</p><p>이 매크로는 매우 초보적인 것이지만, 매크로를 사용해 언어 표기법을 원하는 대로 바꿀 수 있는 강력함을 느끼기에는 부족함이 없을 듯 하다.</p></section><footer class=post-footer><div class="social button-box"><a href=https://twitter.com/share class=twitter-share-button data-show-count=false>Tweet</a>
<a class=twitter-follow-button href=https://twitter.com/ntalbs data-show-count=false>Follow @ntalbs</a>
<script async src=//platform.twitter.com/widgets.js></script></div><nav id=article-nav><a class="article-nav-link-wrap previous" href=/2014/manual-brew-update/ id=article-nav-newer>수작업 brew 포뮬러 업데이트</a>
<a class="article-nav-link-wrap next" href=/2014/private-in-js/ id=article-nav-older>JavaScript에서 private 필드</a></nav></footer></article></main><section class=section><div class=container><aside><div id=disqus_thread></div></aside><script type=text/javascript>var disqus_shortname='ntalbs-stuff',permalink="https://ntalbs.github.io/2014/infix-macro/".replace(/\//g,'/'),disqus_config=function(){this.page.url=permalink,this.page.identifier=permalink};(function(){var e=document,t=e.createElement('script');t.src='https://'+disqus_shortname+'.disqus.com/embed.js',t.setAttribute('data-timestamp',+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=https://ntalbs.github.io/js/index.js type=text/javascript></script>
<script src=https://ntalbs.github.io/js/mode.js type=text/javascript></script><footer class=page-bottom><div class=inner><section class=copyright>© 2008-2022 <a href=/about>ntalbs</a></section><section class=poweredby>Powered by <a class=icon-ghost href=https://gohugo.io>Hugo</a></section></div></footer></body></html>