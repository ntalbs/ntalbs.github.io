<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DB on @ntalbs&#39; stuff</title>
    <link>http://ntalbs.github.io/tags/db/</link>
    <description>Recent content in DB on @ntalbs&#39; stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 09 Jan 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ntalbs.github.io/tags/db/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SQL에서 행을 열로 바꾸는 방법</title>
      <link>http://ntalbs.github.io/2015/sql-transpose/</link>
      <pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2015/sql-transpose/</guid>
      <description>&lt;p&gt;쿼리를 작성하다 보면 행을 열로 또는 열을 행으로 바꾸고 싶은 경우가 생긴다. 데이터 모델을 만들 때 같은 종류의 데이터는 행으로 저장하는 것이 좋지만, 고객은 열로 표현된 형태의 보고서를 보고 싶을 수 있다. 쿼리 결과를 행에서 열로 또는 열에서 행으로 바꾸는 작업은 원리를 이해하면 어렵지 않지만 약간의 기교가 필요하다. 그래서인지 쿼리 결과의 행/열 전환은 SQL 관련 단골 질문이기도 하다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MySQL Row Generator</title>
      <link>http://ntalbs.github.io/2014/mysql-row-generator/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2014/mysql-row-generator/</guid>
      <description>&lt;p&gt;Oracle에서는 &lt;code&gt;connect by&lt;/code&gt;를 사용해 필요한 만큼 행(row)을 생성할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select level from dual connect by level &amp;lt;= 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PostgreSQL에서도 &lt;code&gt;generate_series&lt;/code&gt;를 사용해 쉽게 행을 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from generate_series(1, 100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재귀적 CTE(Common Table Expressions)를 사용하면 특정 DBMS에서만 제공하는 기능을 사용하지 않고 표준 SQL만 사용해 행 생성기(row generator)를 만들 수 있다. PostgreSQL에서는 다음과 같은 식으로 원하는 만큼 행을 생성할 수 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>초보 DBA 삽질기 5</title>
      <link>http://ntalbs.github.io/2014/dba-story-5/</link>
      <pubDate>Sat, 04 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2014/dba-story-5/</guid>
      <description>&lt;p&gt;그동안 프로젝트 성격의 일도 있었지만 대부분은 반복적인 작업이었다. 일이 점점 지겨워지고 있었다. 매일 아침 데이터베이스 상태를 확인하는 것도, 작업을 할 때마다 세 번씩 확인을 받아야 하는 것도 모두 짜증났다. 내가 사고를 쳤기 때문에 이런 절차가 생겼고, 이런 절차를 만든 게 나 자신이었고, 안정적인 운영을 위해서는 이런 절차가 필요하다는 점이 나를 더욱 힘들게 했다. 참을성이 바닥나고 있었다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>초보 DBA 삽질기 4</title>
      <link>http://ntalbs.github.io/2014/dba-story-4/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2014/dba-story-4/</guid>
      <description>&lt;p&gt;입사한지 1년 반이 되어 가고 있었다. 그동안 심각한 장애는 대부분 내 실수에서 비롯되었다. 애플리케이션 서버는 여러 대로 운영하기 때문에 한 대에 문제가 생겨도 거래가 중단되지 않는다. 데이터베이스는 문제가 생기면 모든 거래가 중단되는 단일 실패 지점(Single poing of failure)이었다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>초보 DBA 삽질기 3</title>
      <link>http://ntalbs.github.io/2014/dba-story-3/</link>
      <pubDate>Wed, 24 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2014/dba-story-3/</guid>
      <description>&lt;p&gt;지난 번 사고 후 네 달 이상 장애가 발생하지 않았다. 처음에 조금 실수를 했지만 이제는 어느 정도 자리를 잡았다는 생각이 들었다. 그동안 많은 일을 했고, 특히 전산센터를 이전할 때 내가 작성한 데이터베이스 동기화 프로그램이 중요한 역할을 했다는 점에 자부심을 느꼈다. 몇 달 동안 사고 없이 데이터베이스를 운영하면서 감도 조금 생겼다. &lt;strong&gt;하지만 실수는 방심할 때 찾아오는 법이다.&lt;/strong&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>초보 DBA 삽질기 2</title>
      <link>http://ntalbs.github.io/2014/dba-story-2/</link>
      <pubDate>Mon, 15 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2014/dba-story-2/</guid>
      <description>&lt;p&gt;&lt;strong&gt;잘 돌아가면 건드리지 말라는 말이 있다.&lt;/strong&gt; 100% 완벽하게 이해하지 못하는 시스템에 대해서는 이 말이 좋은 충고일 수도 있겠다는 생각이 든다. 데이터베이스 관리 시스템은 매우 복잡한 소프트웨어이므로 이것을 완벽하게 이해하기란 정말 어려운 일이다. 더군다나 데이터베이스가 어떻게 구성되어 있느냐에 따라 같은 명령도 다른 양상을 보일 수 있다. 중단이 허용되지 않는 데이터베이스 시스템에서 뭔가 작업하려면 더욱 주의해야 하고 가능한 보수적으로 접근해야 한다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>초보 DBA 삽질기 1</title>
      <link>http://ntalbs.github.io/2014/dba-story-1/</link>
      <pubDate>Fri, 12 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2014/dba-story-1/</guid>
      <description>&lt;p&gt;그동안 SI 프로젝트에서 개발 DBA만 하다 처음으로 운영 DBA가 되었다. 그날도 뭘 해야 할지 몰라 데이터베이스 이곳 저곳을 들여다보며 일거리를 찾고 있었다. 모두들 바쁜데 나만 한가한 것 같았다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>생각해볼 문제</title>
      <link>http://ntalbs.github.io/2010/sql-problem/</link>
      <pubDate>Wed, 15 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/sql-problem/</guid>
      <description>&lt;p&gt;1부터 100까지 더하는 프로그램을 짜라면 많은 프로그래머들이 다음과 같이 &lt;code&gt;for&lt;/code&gt; 루프로 1부터 100까지 돌면서 합을 구하는 형식으로 코드를 작성할 것이다. (Python으로 구현)
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>압축 해제와 동시에 import 하기</title>
      <link>http://ntalbs.github.io/2010/uncompress-import/</link>
      <pubDate>Mon, 02 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/uncompress-import/</guid>
      <description>압축된 덤프 파일을 압축 해제와 동시에 import 하는 방법이다. 압축을 해제할 만큼 디스크 공간이 충분하지 않을 때 유용하게 사용할 수 있다. 1. 파이프로 들어오는 데이터를 import 한다. 이 명령은 백그라운드로 실행되도록 한다.
$ imp system/pw fromuser=scott file=pipe log=imp_${dump_file}.log ignore=y &amp;  2. dump 파일을 압축 해제해 파이프로 넘긴다. uncompress로 압축 해제한 다음 $pipe로 넘긴다.
$ uncompress &amp;lt; exp.dmp.Z &amp;gt; $pipe  이를 응용해 다음과 같은 스크립트를 만들 수 있다.</description>
    </item>
    
    <item>
      <title>export와 동시에 압축하기</title>
      <link>http://ntalbs.github.io/2010/export-compress/</link>
      <pubDate>Sun, 01 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/export-compress/</guid>
      <description>다음과 같이 하면 export를 받은 후 압축하지 않고 export와 동시에 압축을 할 수 있다. export 파일 크기가 크고 디스크 용량이 충분하지 않을 때 사용하면 유용하다. 1. named pipe를 만든다. $ mknod /tmp/expimp_pipe p  2. pipe로부터 들어오는 데이터를 압축한다. 이 명령은 백그라운드로 실행되도록 한다.
$ compress &amp;lt; /tmp/expimp_pipe &amp;gt; exp.dmp.Z &amp;  3. pipe에 데이터를 쓴다. $ exp system/pw owner=scott direct=y file=/tmp/expimp_pipe  pipe를 이용해 export 하는 동시에 compress로 압축 저장해 백업을 받는 스크립트는 다음과 같이 작성할 수 있다.</description>
    </item>
    
    <item>
      <title>SQL*Loader 사용법 (초간단 정리)</title>
      <link>http://ntalbs.github.io/2010/sql-loader/</link>
      <pubDate>Tue, 27 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/sql-loader/</guid>
      <description>&lt;p&gt;간단히 참조할 용도로 정리한다. 자세한 사용법은 &lt;a href=&#34;http://docs.oracle.com/cd/E11882_01/server.112/e22490/ldr_concepts.htm#SUTIL003&#34;&gt;매뉴얼&lt;/a&gt;을 참조해야 한다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PostgreSQL 날짜 연산</title>
      <link>http://ntalbs.github.io/2010/postgresql-date/</link>
      <pubDate>Fri, 09 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/postgresql-date/</guid>
      <description>&lt;p&gt;database.sarang.net의 &lt;a href=&#34;http://database.sarang.net/?criteria=pgsql&#34;&gt;PostgreSQL 게시판&lt;/a&gt;에 PostgreSQL에서 &lt;a href=&#34;http://database.sarang.net/?inc=read&amp;amp;aid=8678&amp;amp;criteria=pgsql&amp;amp;subcrit=qna&amp;amp;id=&amp;amp;limit=20&amp;amp;keyword=&amp;amp;page=1&#34;&gt;날짜 연산 관련 질문&lt;/a&gt;이 올라왔다. 답을 생각해보면서 PostgreSQL에서 날짜 관련 함수 및 연산 방법을 간단히 정리해봤다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Archivelog mode에서의 복구</title>
      <link>http://ntalbs.github.io/2010/recover-db-archive-log-mode/</link>
      <pubDate>Thu, 24 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/recover-db-archive-log-mode/</guid>
      <description>&lt;p&gt;아카이브로그 모드에서 복구는 데이터베이스가 닫힌 상태에서 작업할 수도 있고 열린 상태에서 작업할 수도 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>noarchivelog mode에서의 복구</title>
      <link>http://ntalbs.github.io/2010/recover-db-no-archivelog-mode/</link>
      <pubDate>Wed, 23 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2010/recover-db-no-archivelog-mode/</guid>
      <description>&lt;p&gt;redo log 백업이 있을 때와 없을 때의 절차가 다르다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>주어진 주의 첫 날과 마지막 날 구하기</title>
      <link>http://ntalbs.github.io/2009/first-and-last-day-of-week/</link>
      <pubDate>Thu, 03 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/first-and-last-day-of-week/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://database.sarang.net/&#34;&gt;Database.Sarang.net&lt;/a&gt; Q&amp;amp;A 게시판에 특정 주(몇월 몇째주)를 주면 이 주의 첫 날과 마지막 날을 구하는 방법에 대한 질문이 올라왔다. 열심히 머리를 굴려본 결과 해당 주에 포함된 날짜를 구하면 그 주의 첫 날과 마지막 날을 구할 수 있음을 알게 됐고, 다음과 같은 쿼리를 작성했다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>오라클 데이터베이스 생성하기</title>
      <link>http://ntalbs.github.io/2009/create-db/</link>
      <pubDate>Wed, 11 Nov 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/create-db/</guid>
      <description>&lt;p&gt;오라클 데이터베이스를 생성할 때 보통은 DBCA를 이용한다. 그러나 DBCA만 사용해 DB를 생성하다보면, DBCA를 사용할 수 없는 상황에는 당황하게 된다. 다음은 DBCA를 이용할 수 없는 경우 오라클 데이터베이스를 생성하는 절차다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Undo 테이블스페이스 크기 변경 방법</title>
      <link>http://ntalbs.github.io/2009/resizing-undb-ts/</link>
      <pubDate>Tue, 10 Nov 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/resizing-undb-ts/</guid>
      <description>&lt;p&gt;Oracle9i에서 &lt;code&gt;UNDO&lt;/code&gt; 테비블스페이스를 &lt;code&gt;auto mode&lt;/code&gt;로 사용할 때, &lt;code&gt;UNDO&lt;/code&gt; 테이블스페이스를 변경하는 방법이다. &lt;code&gt;Undo&lt;/code&gt; 테이블스페이스의 데이터 파일이 너무 커진 경우 데이터 파일 크기를 줄이고 싶지만, 데이터 파일의 크기를 직접 줄일 수는 없다. 따라서 새로운 &lt;code&gt;UNDO&lt;/code&gt; 테이블스페이스를 만들고 크기를 적절히 지정한 데이터 파일을 할당한 다음, 데이터베이스에 지정된 &lt;code&gt;UNDO&lt;/code&gt; 테이블스페이스를 변경해야 한다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>login.sql</title>
      <link>http://ntalbs.github.io/2009/login-sql/</link>
      <pubDate>Thu, 20 Aug 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/login-sql/</guid>
      <description>&lt;p&gt;&lt;code&gt;SQLPATH&lt;/code&gt; 환경 변수 설정하고 &lt;code&gt;SQLPATH&lt;/code&gt;에 다음 내용으로 login.sql 파일을 만들어 놓는다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>데이터 생성 SQL</title>
      <link>http://ntalbs.github.io/2009/data-generator/</link>
      <pubDate>Tue, 14 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/data-generator/</guid>
      <description>&lt;p&gt;Oracle에서라면 다음 쿼리로 row를 생성할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 1~100까지 숫자 생성 (100 rows)
select level from dual connect by level &amp;lt;= 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 row 생성 쿼리를 이용하면 테스트 데이터를 원하는 만큼 생성하는 것도 쉽고, 간단한 문제를 풀 때도 유용하다. 예를 들어 얼마 전 kldp.org에 올라왔던 1~45의 숫자 중 랜덤하게 6개를 선택해 표시하는 문제도 다음과 같이 SQL로 풀 수 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DBMS 성능 테스트</title>
      <link>http://ntalbs.github.io/2009/db-performance/</link>
      <pubDate>Mon, 16 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/db-performance/</guid>
      <description>&lt;p&gt;지금까지 주로 Oracle을 사용해왔으나, 현재의 회사에서는 MySQL을 주로 사용하며 일부 시스템에서 PostgreSQL을 사용한다. 현재 MySQL을 사용하는 부분에서 지속적인 성능 문제가 발생하고 있는데, 이는 MySQL을 충분히 알지 못해 나타나는 문제일 수도 있다. MySQL을 사용하면서 지금까지 알고 있던 DBMS에 대한 지식(주로 Oracle에 대한)이 무용지물인 경우가 많았기 때문이다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>데이터베이스 링크 생성</title>
      <link>http://ntalbs.github.io/2009/create-dblink/</link>
      <pubDate>Mon, 16 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2009/create-dblink/</guid>
      <description>&lt;p&gt;데이터베이스 링크를 만들 때 &lt;code&gt;using&lt;/code&gt; 뒤에 다음과 같이 connect string을 직접 적어줄 수도 있다. 데이터베이스 링크만을 위해 &lt;code&gt;tnsnames.ora&lt;/code&gt; 파일에 &lt;code&gt;tnsalias&lt;/code&gt;를 등록하지 않아도 되겠다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AWR 기본</title>
      <link>http://ntalbs.github.io/2008/awr/</link>
      <pubDate>Fri, 12 Dec 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/awr/</guid>
      <description>&lt;p&gt;Oracle10g부터 추가된 AWR(Automatic Workload Repository) 기본 사용법이다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>dbms_metadata를 이용한 DDL 추출</title>
      <link>http://ntalbs.github.io/2008/dbms-metadata/</link>
      <pubDate>Thu, 04 Dec 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/dbms-metadata/</guid>
      <description>&lt;p&gt;&lt;code&gt;dbms_metadata&lt;/code&gt; 패키지를 이용해 DDL 추출하는 방법이다. 특정 스키마의 모든 DB 객체에 대한 DDL을 추출하려면 export를 사용하는 것이 더 편하다. (&lt;a href=&#34;http://ntalbs.github.io/2008/extract-ddl/&#34;&gt;특정 스키마의 DDL 추출 참조&lt;/a&gt;)
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>오라클 인덱스 용량 산정 방법</title>
      <link>http://ntalbs.github.io/2008/sizing-index/</link>
      <pubDate>Tue, 18 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/sizing-index/</guid>
      <description>&lt;p&gt;인덱스 용량을 산정하기 위한 방법인데 조금 복잡하다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>v$session과 주변 테이블 정리</title>
      <link>http://ntalbs.github.io/2008/vsession/</link>
      <pubDate>Mon, 17 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/vsession/</guid>
      <description>오라클의 다이나믹 퍼포먼스 뷰인 v$session과 v$process, v$transaction등 관련 테이블간의 연관 관계를 정리해봤다. 요즘은 Orange나 Toad와 같은 도구를 사용하기 때문에, 이런 테이블을 직접 조회할 일이 많지는 않지만, 가끔씩 아쉬울 때도 있다.</description>
    </item>
    
    <item>
      <title>오라클 테이블 용량 산정 방법</title>
      <link>http://ntalbs.github.io/2008/sizing-table/</link>
      <pubDate>Mon, 17 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/sizing-table/</guid>
      <description>&lt;p&gt;테이블 용량을 산정하기 위한 방법인데 조금 복잡하다. 어차피 추정이므로 간단하게 $(평균\ row \ 크기) \times (데이터\ 건수) \times 1.3$ 정도로 해도 되지 않을까 싶다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>특정 스키마 DDL 추출</title>
      <link>http://ntalbs.github.io/2008/extract-ddl/</link>
      <pubDate>Sat, 08 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/extract-ddl/</guid>
      <description>&lt;p&gt;다음과 같이 하면 exp/imp 도구를 사용해 특정 스키마의 DDL을 추출할 수 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>무한 row 생성 쿼리</title>
      <link>http://ntalbs.github.io/2008/row-generator/</link>
      <pubDate>Mon, 03 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/row-generator/</guid>
      <description>&lt;p&gt;Oracle에서는 다음과 같이 &lt;code&gt;connect by&lt;/code&gt;절을 사용해 원하는 만큼 row를 만들어낼 수 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>오라클에서 factorial 구하기</title>
      <link>http://ntalbs.github.io/2008/oracle-factorial/</link>
      <pubDate>Mon, 03 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/oracle-factorial/</guid>
      <description>&lt;p&gt;오라클에 &lt;code&gt;factorial&lt;/code&gt; 함수가 없지만 다음과 같이 구할 수 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>인덱스 비교</title>
      <link>http://ntalbs.github.io/2008/comp-indexes/</link>
      <pubDate>Mon, 03 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/comp-indexes/</guid>
      <description>&lt;p&gt;개발DB와 테스트DB, 또는 테스트DB와 운영DB간 인덱스를 비교할 때는 다음 쿼리를 사용할 수 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>테이블 비교</title>
      <link>http://ntalbs.github.io/2008/comp-tables/</link>
      <pubDate>Mon, 03 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/comp-tables/</guid>
      <description>프로젝트를 하다보면 개발DB와 테스트DB 또는 테스트DB와 운영DB간 스키마를 비교해 차이점이 없는지 확인할 일이 많다. 다음은 테이블과 컬럼을 비교하는 스크립트다. Full Outer Join을 사용할 수도 있으나, 결과가 제대로 나오지 않거나 에러(ora-600)가 발생한다(Oracle 9i, 10g에서 모두 에러 발생했음). 그냥 left outer join, right outer join한 후 둘을 union 하는 것이 결과가 제대로 나온다. (with절은 Oracle 9i부터 사용 가능함.)
with a as ( select table_name, column_name, decode(data_type, &#39;CHAR&#39;, data_type||&#39;(&#39;||data_length||&#39;)&#39;, &#39;VARCHAR2&#39;, data_type||&#39;(&#39;||data_length||&#39;)&#39;, &#39;NUMBER&#39;, data_type||&#39;(&#39;||data_precision||&#39;,&#39;||data_scale||&#39;)&#39;, data_type) data_type, nullable from all_tab_columns where owner = &#39;XXX&#39; and table_name not like &#39;BIN$%&#39; ), b as ( select table_name, column_name, decode(data_type, &#39;CHAR&#39;, data_type||&#39;(&#39;||data_length||&#39;)&#39;, &#39;VARCHAR2&#39;, data_type||&#39;(&#39;||data_length||&#39;)&#39;, &#39;NUMBER&#39;, data_type||&#39;(&#39;||data_precision||&#39;,&#39;||data_scale||&#39;)&#39;, data_type) data_type, nullable from all_tab_columns&amp;lt;b id=&amp;quot;ncsj&amp;quot;&amp;gt;@testdb&amp;lt;/b&amp;gt; where owner = &#39;XXX&#39; and table_name not like &#39;BIN$%&#39; ) select decode(a.</description>
    </item>
    
    <item>
      <title>SELECT 결과를 shell 변수로 가져오기</title>
      <link>http://ntalbs.github.io/2008/select-shell/</link>
      <pubDate>Sat, 01 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/select-shell/</guid>
      <description>&lt;p&gt;select한 결과를 shell에서 참조해야 하는 경우 다음과 같이 하면 된다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL*Plus에서 &#39;&amp;&#39;가 포함된 문자열을 변수로 인식하지 않게 하기</title>
      <link>http://ntalbs.github.io/2008/sqlplus-ampersand/</link>
      <pubDate>Sat, 01 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/sqlplus-ampersand/</guid>
      <description>&lt;p&gt;문자열 자체에 &lt;code&gt;&amp;amp;&lt;/code&gt;가 포함되어 있는 경우 SQL*Plus에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 뒤의 단어를 변수로 인식해 그에 대한 값의 입력을 요구한다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>db_files 개수에 포함되는 파일은?</title>
      <link>http://ntalbs.github.io/2008/db-files/</link>
      <pubDate>Sat, 01 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/db-files/</guid>
      <description>&lt;p&gt;현재 우리 운영DB는 &lt;code&gt;db_files&lt;/code&gt; 파라미터 값이 매우 작게 잡혀있다. 따라서 빨리 값을 늘려줘야 하는데, 당장 운영중인 DB를 내리고 파라미터 값을 바꿀 수는 없다. 그런데 여기서 궁금증 하나 생겼다. &lt;code&gt;db_files&lt;/code&gt;는 데이터 파일 개수만 제한하는 것일까, 아니면 temp 파일도 여기에 포함되는 것일까? 혹시 온라인 리두로그는? 혹시 컨트롤 파일도 포함되는 것일까? 지금까지는 당연히 데이터 파일 수를 제한하는 것이라 생각했었는데, 이런 궁금증이 생기니 확신을 할 수가 없다. 지금까지 명확하게 알지 못하고 작업하다가 사고친 게 어디 한두번이던가?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LONG형 컬럼을 가진 테이블의 테이블스페이스 이동</title>
      <link>http://ntalbs.github.io/2008/long-move-ts/</link>
      <pubDate>Fri, 31 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/long-move-ts/</guid>
      <description>&lt;p&gt;테이블을 다른 테이블스페이스로 옮기려면 다음과 같이 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER TABLE t MOVE TABLESPACE ts_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러나 &lt;code&gt;LONG&lt;/code&gt;형 컬럼을 포함하고 있는 테이블에 위 명령을 실행하면 &lt;code&gt;ora-00997&lt;/code&gt; 에러가 발생한다. CTAS를 사용해 테이블 복사를 시도해도 같은 에러가 발생한다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL*Plus 프롬프트 설정</title>
      <link>http://ntalbs.github.io/2008/sqlplus-prompt/</link>
      <pubDate>Fri, 31 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/sqlplus-prompt/</guid>
      <description>&lt;p&gt;SQL*Plus의 프롬프트를 &lt;code&gt;username@INSTANCE_NAME &amp;gt;&lt;/code&gt;과 같은 식으로 설정하면 현재 로그인한 인스턴스와 사용자 이름을 확인할 수 있어 편하다. logn.sql 스크립트를 만들어 여기에 프롬프트 설정 코드를 넣어두면 된다. Effective Oracle 책(p79)에는 설정 코드가 조금 복잡하게 나와 있다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>인덱스 중복과 클러스터링 팩터</title>
      <link>http://ntalbs.github.io/2008/index-dup-and-clustering-factor/</link>
      <pubDate>Fri, 31 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/index-dup-and-clustering-factor/</guid>
      <description>&lt;p&gt;테이블 T에 다음과 같은 인덱스가 있다면 &lt;code&gt;ix01&lt;/code&gt;은 삭제해야 한다고 생각했다.
* &lt;code&gt;ix01&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;
* &lt;code&gt;ix02&lt;/code&gt;: &lt;code&gt;a+b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ix02&lt;/code&gt;을 이용하면 &lt;code&gt;ix01&lt;/code&gt;을 사용해야 하는 경우를 모두 포괄할 수 있으니 &lt;code&gt;ix02&lt;/code&gt;만 남겨놓고 나머지는 삭제하는 것이 맞다고 생각했던 것이다. 그러나 문제가 항상 그렇게 단순하지만은 않은 듯 하다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DB 링크 삭제 시 제약사항</title>
      <link>http://ntalbs.github.io/2008/deleting-db-link/</link>
      <pubDate>Thu, 30 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/deleting-db-link/</guid>
      <description>&lt;p&gt;불필요한 데이터베이스 링크가 난무하는 것 같아 정리하기로 마음을 먹었다. 일단 개발DB에서 운영DB로의 데이터베이스 링크는 허용할 수 없으므로 이것부터 삭제하기로 했다. 개발DB에 &lt;code&gt;sys&lt;/code&gt; 계정으로 로그인한 다음 &lt;code&gt;dba_db_links&lt;/code&gt; 테이블을 조회해 개발DB에서 운영DB로 연결되는 데이터베이스 링크를 하나씩 확인했다. &lt;code&gt;public&lt;/code&gt; 데이터베이스 링크를 삭제할 때는 &lt;code&gt;drop public database link ...&lt;/code&gt; 명령으로 간단하게 삭제했다. 그리고 &lt;code&gt;xxx&lt;/code&gt; 스키마에 있는 데이터베이스 링크를 삭제하기 위해 &lt;code&gt;drop database link xxx.{db_link_name}&lt;/code&gt; 명령을 날렸는데, 데이터베이스 링크를 찾을 수 없다며 &lt;code&gt;ora-02024&lt;/code&gt; 에러가 발생했다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Oracle XDB 비활성화 방법</title>
      <link>http://ntalbs.github.io/2008/disabling-xdb-in-oracle/</link>
      <pubDate>Thu, 30 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/disabling-xdb-in-oracle/</guid>
      <description>&lt;p&gt;Oracle9i부터는 XML DB가 포함되어 있는데, 이 녀석은 HTTP/WebDAV과 FTP 포트로 각각 &lt;code&gt;8080&lt;/code&gt;과 &lt;code&gt;2100&lt;/code&gt; 포트를 사용한다. 데이터베이스 서버에 Oracle만 실행 중이라면 XML DB가 떠있다고 해서 당장 문제될 것이 없으니 그냥 무시할 수도 있다(보안을 생각한다면 내려야 하겠지만). 개발 서버나 테스트 서버의 경우 &lt;code&gt;8080&lt;/code&gt; 포트를 쓰는 다른 서버 프로그램(가령 Tomcat 같은)을 띄워야 하는 경우 포트가 충돌해 문제가 발생할 수 있다. Oracle9i에는 그나마 DBCA를 이용해 DB를 생성할 때 XML DB를 제외할 수 있는 옵션이 있었던 것 같은데, 10g에는 그 옵션이 사라져버렸다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>하지 말 것 목록</title>
      <link>http://ntalbs.github.io/2008/not-to-do-things/</link>
      <pubDate>Thu, 30 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/not-to-do-things/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;사용자로부터 문자열 리터럴을 입력받아 SQL을 만들지 말 것. (eg: 항상 바인드 변수를 사용할 것)&lt;/li&gt;
&lt;li&gt;데이터가 없는 상태 또는 실제 시스템의 극히 일부 데이터만 있는 상태에서 테스트하지 말 것. 실제 시스템의 통계 정보를 불러들이는 것도 소용 없음. &lt;strong&gt;실제로 어떻게 되는지를 보려면 실제 만큼의 데이터가 필요함.&lt;/strong&gt;</description>
    </item>
    
    <item>
      <title>DBMS_RANDOM 패키지 사용법</title>
      <link>http://ntalbs.github.io/2008/dbms-random/</link>
      <pubDate>Wed, 29 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/dbms-random/</guid>
      <description>&lt;p&gt;랜덤한 숫자나 문자열을 만들 때 &lt;code&gt;DBMS_RANDOM&lt;/code&gt; 패키지를 사용하면 된다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>set timing을 이용한 SQL 실행 속도 측정법</title>
      <link>http://ntalbs.github.io/2008/set-timing/</link>
      <pubDate>Wed, 29 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/set-timing/</guid>
      <description>&lt;p&gt;SQL*Plus에서 실행시킨 SQL 또는 PL/SQL 블록의 실행속도를 보려면 다음과 같이 &lt;code&gt;set timing on&lt;/code&gt;을 사용하면 된다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TIMESTAMP 컬럼으로 파티션 하는 방법</title>
      <link>http://ntalbs.github.io/2008/partition-by-timestamp/</link>
      <pubDate>Tue, 28 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/partition-by-timestamp/</guid>
      <description>&lt;p&gt;일반적으로 range 파티션 테이블을 만들 때는 다음과 같이 한다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>날짜 데이터 저장</title>
      <link>http://ntalbs.github.io/2008/storing-dates/</link>
      <pubDate>Tue, 28 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/storing-dates/</guid>
      <description>&lt;p&gt;DBMS마다 날짜와 시간을 저장할 수 있는 데이터 타입을 제공한다. 그러나 날짜와 시간을 저장하는 데 &lt;code&gt;&#39;YYYYMMDD&#39;&lt;/code&gt;, &lt;code&gt;&#39;HH24MISS&#39;&lt;/code&gt; 형식의 문자열을 사용하는 경우도 많다. 인터넷 문서나 오래된 책을 찾아보면 날짜를 저장할 때 &lt;code&gt;DATE&lt;/code&gt; 타입을 사용하지 말고 문자열로 저장하는 것이 좋다고 주장하는 경우도 흔하게 볼 수 있다. 날짜나 시간 데이터를 저장하는 데 문자열 데이터 타입을 사용하면 불필요하게 저장 공간이 늘어날 뿐 아니라 데이터 정합성이 떨어지고 성능에까지 영향을 미칠 수 있다. 이에 대해서 하나씩 살펴보자
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>올바른 데이터 타입 사용하기</title>
      <link>http://ntalbs.github.io/2008/data-type/</link>
      <pubDate>Tue, 28 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/data-type/</guid>
      <description>&lt;p&gt;데이터베이스에 테이블을 만들 때 각 컬럼의 데이터 타입을 정하는 것은 무척 쉬워 보인다. 데이터베이스에서 기본으로 제공하는 데이터 타입 종류가 엄청나게 많은 것도 아니고, 테이블에 저장할 데이터란 것도 대부분의 경우는 뻔하기 때문이다. 그러나 실제 데이터베이스를 보면 데이터 타입이 잘못 지정된 컬럼을 매우 자주 볼 수 있으며, 신규 테이블 생성을 요청할 때나 또는 컬럼 추가를 요청할 때도 데이터 타입을 잘못 지정해 요청하는 경우가 많다.

일단 테이블에 데이터가 쌓이기 시작하면 잘못된 것을 알아도 바꾸기가 쉽지 않은 경우가 대부분이므로, 컬럼의 데이터 타입을 정할 때는 신중하게 생각해 저장하고자 하는 데이터에 맞는 데이터 타입을 선정해야 한다. 다음은 오라클 데이터베이스에서 기본적인 데이터 타입을 선택하는 방법이다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Direct-path Insert시 주의사항</title>
      <link>http://ntalbs.github.io/2008/direct-path-load/</link>
      <pubDate>Mon, 27 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/direct-path-load/</guid>
      <description>뭔가에 대해 어설프게 아는 것은 큰 위험을 초래할 수 있다. 이번에는 Direct-path Insert에 대한 어설픈 지식으로 큰 사고를 낼 뻔 했다. 지금까지 알고 있었던 사실은 Direct-path Insert를 이용하면 redo와 undo 로깅을 생략해 성능을 향상시킬 수 있다는 것이었다. 따라서 테이블에 대량의 데이터를 넣을 때 이 방법을 활용하곤 했다. 그러나 Direct-path INSERT를 하는 동안 테이블에는 LOCK이 걸리고 작업이 끝날 때까지 해당 테이블에 DML 작업을 할 수 없게 된다는 사실은 알지 못했다. 만약 확인하지 않고 거래 데이터를 전환해 넣을 때 Direct-path INSERT를 썼더라면 장애가 생길 뻔 했다.</description>
    </item>
    
    <item>
      <title>다이렉트 로드와 인덱스</title>
      <link>http://ntalbs.github.io/2008/direct-load-and-index/</link>
      <pubDate>Mon, 27 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/direct-load-and-index/</guid>
      <description>&lt;p&gt;대량 데이터를 로드할 때 항상 궁금했던 것이 있다. 다음 두 가지 방법 중 어떤 것이 빠를까 하는 것이다.
* 방법1: 인덱스가 있는 상태에서 그냥 다이렉트 모드로 로드
* 방법2: 인덱스를 날리고 로드한 다음 인덱스를 생성
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>컬럼 추가와 디폴트 값</title>
      <link>http://ntalbs.github.io/2008/add-column-and-default-value/</link>
      <pubDate>Mon, 27 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/add-column-and-default-value/</guid>
      <description>&lt;p&gt;기존 테이블에 컬럼을 추가할 때 디폴트 값을 지정하면 기존 데이터는 건드리지 않고 새로 추가되는 데이터에 대해서만 디폴드 값이 적용되는 줄 알고 있었다. 그런데 작업을 하다가 그동안 잘못 알고 있었다는 것을 알게 되었다. 다음 두 작업은 완전히 다르게 진행된다.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MINIMIZE RECORDS_PER_BLOCK</title>
      <link>http://ntalbs.github.io/2008/records-per-block/</link>
      <pubDate>Sat, 25 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/records-per-block/</guid>
      <description>&lt;p&gt;SQL Reference에 보면 &lt;code&gt;records_per_block&lt;/code&gt;절에 대해 다음과 같이 설명되어 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;instruct Oracle Database to calculate the largest number of records in any block in the table and to limit future inserts so that no block can contain more than that number of records.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>원하는 시간에만 DB 작업 실행하기</title>
      <link>http://ntalbs.github.io/2008/dbms-job/</link>
      <pubDate>Fri, 24 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://ntalbs.github.io/2008/dbms-job/</guid>
      <description>&lt;p&gt;예전에 &lt;a href=&#34;http://database.sarang.net/?criteria=oracle&#34;&gt;database.sarang.net 오라클 게시판&lt;/a&gt;에 &lt;code&gt;DBMS_JOB&lt;/code&gt;을 이용해 원하는 작업을 08시, 14시, 20시에 실행시키는 방법을 묻는 질문이 올라왔다. 작업 간격이 규칙적일 때는 문제가 간단하지만 원하는 시간 간격이 불규칙하므로 그냥 JOB을 세 개 등록하면 어떻겠냐고 답했더니 이번에는 이 작업을 평일에만 실행시키게 하고 싶다고 했다. 즉 평일 08시, 14시, 20시에 작업이 실행되도록 하고 싶다는 것이었다.
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>