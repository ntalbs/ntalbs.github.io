<!DOCTYPE html><html><head><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>프로젝트 오일러 15 | ntalbs&#39; stuff</title><meta name="description" content=""><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="ntalbs' stuff"></head><body class="home-template"><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button> <a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archives">Archives</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></div></div></nav><div id="progress"><div id="bar"></div><div class="container"><div id="scroll-title">프로젝트 오일러 15</div></div></div><header class="site-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header><p class="post-meta"><time datetime="2015-04-05T23:00:00.000Z" itemprop="datePublished">2015-04-06</time> on <a href="/tags/Project-Euler/" style="margin:0 5px">Project-Euler</a><a href="/tags/Clojure/" style="margin:0 5px">Clojure</a></p><h1 class="post-title">프로젝트 오일러 15</h1></header><section class="post-content"><blockquote><p>20×20 격자의 좌상단에서 우하단으로 가는 경로의 수?<br>문제 자세히 보기: <a href="http://euler.synap.co.kr/prob_detail.php?id=15" target="_blank" rel="external">[국어]</a> <a href="https://projecteuler.net/problem=15" target="_blank" rel="external">[영어]</a></p></blockquote><p>격자에서 오른쪽으로 이동하는 경로를 <code>r</code>(right), 아래쪽으로 이동하는 경로를 <code>d</code>(down)라 하면 2x2 격자의 좌상단에서 우하단으로 가는 경로는 다음과 같은 식으로 표현할 수 있다.<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rrdd, rdrd, rddr</span><br><span class="line">drrd, drdr, ddrr</span><br></pre></td></tr></table></figure><p>결국 이 문제는 <code>rrdd</code>에 대한 순열을 구하는 문제가 된다. <code>r</code> 끼리 또는 <code>d</code>끼리는 순서가 바뀌어도 상관이 없다. 따라서 2x2 격자의 좌상단에서 우하단으로 가는 경로의 수는 다음과 같이 구할 수 있다.</p><span>$$\begin{aligned} (number\, of\, paths) &amp;= \frac{4!}{2! \times 2!} = 6 \end{aligned}$$</span><p>20x20 격자라면 <code>r</code> 20개, <code>d</code> 20개를 일렬로 늘어놓을 수 있는 경우의 수를 구하는 문제가 된다. 따라서 다음 식을 계산하면 문제의 답을 구할 수 있다.</p><span>$$\begin{aligned} (number\, of\, paths) &amp;= \frac{40!}{20! \times 20!} \end{aligned}$$</span><p><code>n!</code>을 구하는 함수가 있다면 답을 구한 것이나 마찬가지다. <code>factorial</code>이 구현되어 있다고 한다면 답은 다음과 같이 구할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> solve []</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [f40 (<span class="name">factorial</span> <span class="number">40</span>) f20 (<span class="name">factorial</span> <span class="number">20</span>)]</span><br><span class="line">    (/ f40 (<span class="name">*'</span> f20 f20))))</span><br></pre></td></tr></table></figure><p>결과는 다음과 같다.</p><pre class="console">
p015=> (time (solve))
"Elapsed time: 0.16456 msecs"
13784652????N
</pre><p>문제 풀이에 대해서는 더 이상 설명할 것이 없으므로, Factorial 함수를 구현하는 방법에 대해 정리해보려 한다.</p><h2 id="Factorial-함수-구현"><a href="#Factorial-함수-구현" class="headerlink" title="Factorial 함수 구현"></a>Factorial 함수 구현</h2><p>Factorial은 보통 다음과 같이 재귀적으로 정의된다.</p><span>$$\begin{aligned} n! = \begin{cases} 1 &amp; \mbox{if } n = 0,\\ n(n-1)! &amp; \mbox {if } n &gt; 0 \end{cases} \end{aligned}$$</span><p>Clojure 코드로는 다음과 같이 구현할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> fact1 [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> n)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    (<span class="name">*'</span> n (<span class="name">fact1</span> (<span class="name"><span class="builtin-name">dec</span></span> n)))))</span><br></pre></td></tr></table></figure><p><code>factorial</code>은 매우 빠르게 커지는 함수로 $21!$만 되어도 <code>Long</code>의 표현 범위를 넘는다. 범위에 관계 없이 <code>factorial</code>을 구할 수 있도록 <code>*&#39;</code>을 이용해 곱셈을 구했다. 그러나 이렇게 작성하면 매 재귀호출 때마다 스택을 소비하므로 큰 수의 Factorial을 구할 때는 <code>StackOverflowError</code>가 발생할 수 있다.</p><pre class="console">
user=> (fact1 20000)

StackOverflowError   clojure.lang.Util.equiv (Util.java:30)
</pre><p>꼬리재귀(Tail Recursion)을 사용하면 <code>StackOverflowError</code>를 피할 수 있다. Clojure에서 꼬리재귀를 사용하려면 <code>recur</code> Special Form을 사용해야 한다. <code>recur</code>는 tail position에서만 사용할 수 있는데, 위 <code>factorial</code> 구현에서 재귀호출하는 부분은 tail position이 아니다. 따라서 꼬리재귀를 사용하려면 다음과 같이 보조 함수를 도입해 함수 형태를 변경할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> fact-helper [n acc]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> n)</span><br><span class="line">    acc</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">dec</span></span> n) (<span class="name">*'</span> n acc))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> fact2 [n]</span><br><span class="line">  (<span class="name">fact-helper</span> n <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>이렇게 하면 큰 수에 대해서도 <code>StackOverflowError</code>가 발생하지 않고 잘 동작한다.</p><pre class="console">
user=> (factorial 20000)
18192063202303451348276417568...
</pre><p>그러나 <code>fact-helper</code>와 같은 보조 함수가 <code>factorial</code> 밖에서 보이는 게 불만이다. <code>letfn</code>을 사용하면 보조 함수를 <code>factorial</code> 함수 안으로 숨길 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> fact3 [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">letfn</span></span> [(<span class="name">f</span> [n acc]</span><br><span class="line">            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> n)</span><br><span class="line">              acc</span><br><span class="line">              (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">dec</span></span> n) (<span class="name"><span class="builtin-name">*</span></span> n acc))))]</span><br><span class="line">    (<span class="name">f</span> n <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>또는 <code>loop</code>를 사용할 수도 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> fact4 [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n n, acc <span class="number">1</span>]</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> n)</span><br><span class="line">      acc</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">dec</span></span> n) (<span class="name">*'</span> n acc)))))</span><br></pre></td></tr></table></figure><p>Factorial 함수는 0 또는 양의 정수에 대해서만 유효하다. <code>fact1</code>의 경우 인자가 음수일 경우 <code>StackOverflowError</code>가 발생할 것이고, <code>fact2</code>, <code>fact3</code>, <code>fact4</code>는 무한루프에 빠질 것이다. 따라서 다음과 같이 선행조건(precondition)을 추가할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> fact4 [n]</span><br><span class="line">  &#123;<span class="symbol">:pre</span> [(<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">pos?</span></span> n) (<span class="name"><span class="builtin-name">zero?</span></span> n)) (<span class="name"><span class="builtin-name">integer?</span></span> n)]&#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>Factorial을 다음과 같이 정의할 수도 있다.</p><span>$$\begin{aligned} n! = \prod_{k=1}^n k = 1 \times 2\, \times ... \times\, n \end{aligned}$$</span><p>이 정의를 그대로 Clojure 코드로 옮기면 다음과 같다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> factorial [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">apply</span></span> *' (<span class="name"><span class="builtin-name">range</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))</span><br></pre></td></tr></table></figure><p><code>apply</code> 대신 <code>reduce</code>를 사용할 수도 있다.</p><p>이 구현이 0에 대해서도 유효할까?</p><pre class="console">
user=> (factorial 0)
1
</pre><p>특별히 해준 것도 없는데 0을 입력했을 때 결과가 제대로 나오는 이유는 <code>*&#39;</code> 함수(<code>*</code>도 마찬가지)에 있다. <code>*&#39;</code> 함수는 인자가 없는 경우 1을 리턴하도록 되어 있다. 위 <code>factorial</code> 함수에 0을 입력한 경우 <code>(range 1 (inc 0))</code>은 <code>()</code> 즉 빈 리스트가 될 테고 빈 리스트에 <code>*&#39;</code>를 <code>apply</code>하면 <code>*&#39;</code>의 정의에 따라 1이 리턴된다. 인자가 없는 경우 <code>*&#39;</code>가 1을 리턴하도록 한 이유는 1이 곱셈에 대한 항등원이기 때문일 것이다. <code>+&#39;</code> 함수(<code>+</code>도 마찬가지)의 경우는 인자가 주어지지 않으면 0을 리턴하는데 이 또한 0이 덧셈에 대한 항등원이기 때문일 것이다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://en.wikipedia.org/wiki/Factorial" target="_blank" rel="external">Factorial</a></li><li><a href="http://betterexplained.com/articles/navigate-a-grid-using-combinations-and-permutations/" target="_blank" rel="external">Navigate a Grid Using Combinations And Permutations</a></li><li><a href="https://github.com/ntalbs/euler/blob/master/src/p015.clj" target="_blank" rel="external">프로젝트 오일러 15 풀이 소스 코드</a></li></ul></section><footer class="post-footer"><nav id="article-nav"><a href="/2015/statement-expresssion/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption label label-default">Prev</strong> <span class="article-nav-title">statement와 expression</span> </a><a href="/2015/project-euler-014/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">프로젝트 오일러 14</span> <strong class="article-nav-caption label label-default">Next</strong></a></nav><section id="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></footer></article></main><footer class="site-footer"><div class="inner"><section class="copyright">&copy; 2008-2015 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="http://hexo.io">Hexo</a></section></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script type="text/javascript" src="/js/jquery.fitvids.js"></script><script type="text/javascript" src="/js/index.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>!function(e,a,t,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=a.createElement(t),o=a.getElementsByTagName(t)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-2098194-3","auto"),ga("require","displayfeatures"),ga("send","pageview")</script><script type="text/javascript">var disqus_shortname="ntalbs-stuff";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>