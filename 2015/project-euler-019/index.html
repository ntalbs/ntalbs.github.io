<!doctype html><html><head><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3882204692252974" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-2098194-3"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-2098194-3")</script><meta charset=utf-8><meta http-equiv=content-language content="ko-KR"><meta name=google-site-verification content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta name=description content="
20세기에서, 매월 1일이 일요일인 경우는 몇 번?
문제 자세히 보기: [국어] [영어]

Java에서 제공하는 Calendar를 사용하면 쉽게 답을 구할 수 있다. 그러나 Calender는 가변객체(mutable object)인데다 클래스도 잘못 설계되어 있어 코드 모양이 어그러진다. Java 8부터는 거지 같은 Calendar 대신 LocalDate를 사용할 수 있다. LocalDate는 값 객체로 Clojure에서 사용해도 코드가 어그러지지 않는다. 조금 더 생각하면 라이브러리의 도움을 받지 않고도 풀 수 있다."><meta property="og:title" content="프로젝트 오일러 19 @ntalbs' stuff"><meta property="og:site_name" content="@ntalbs' stuff"><meta property="og:description" content="
20세기에서, 매월 1일이 일요일인 경우는 몇 번?
문제 자세히 보기: [국어] [영어]

Java에서 제공하는 Calendar를 사용하면 쉽게 답을 구할 수 있다. 그러나 Calender는 가변객체(mutable object)인데다 클래스도 잘못 설계되어 있어 코드 모양이 어그러진다. Java 8부터는 거지 같은 Calendar 대신 LocalDate를 사용할 수 있다. LocalDate는 값 객체로 Clojure에서 사용해도 코드가 어그러지지 않는다. 조금 더 생각하면 라이브러리의 도움을 받지 않고도 풀 수 있다."><meta property="og:url" content="https://ntalbs.github.io/2015/project-euler-019/"><meta name=og:image content="https://ntalbs.github.io/images/ntalbs.jpg"><meta name=twitter:card content="summary"><meta name=twitter:site content="@ntalbs"><meta name=twitter:creator content="@ntalbs"><meta name=viewport content="width=device-width,initial-scale=1"><title>프로젝트 오일러 19 @ntalbs' stuff</title><link rel="shortcut icon" href=/images/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/highlight.css></head><body><div id=progress><div id=bar></div><div class=container><div id=scroll-title>프로젝트 오일러 19</div></div></div><nav class=navbar role=navigation><div class=container><div class=navbar-header><button type=button class="navbar-toggle unselectable" data-toggle=collapse data-target=#nav-items>+</button>
<a class="navbar-brand unselectable" href=/>@ntalbs' stuff</a></div><div class="navbar-items collapsed" id=nav-items><ul><li><input id=search type=search placeholder="Search this site" autocomplete=off></li><li><a class=unselectable href=/archive/>Archive</a></li><li><a class=unselectable href=/tags/>Tags</a></li><li><a class=unselectable href=/about/>About</a></li><li><a id=mode-switch class=unselectable href=#></a></li></ul></div></div></nav><header class=page-head><div class=container><p class=blog-description>내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class=container role=main><article class=post><header><p class=post-meta><time datetime=2015-05-15 itemprop=datePublished>2015-05-15</time>
on
<a href=/tags/project-euler/>Project-Euler</a>
<a href=/tags/clojure/>Clojure</a></p><h1 class=post-title>프로젝트 오일러 19</h1></header><section class=post-content><blockquote><p>20세기에서, 매월 1일이 일요일인 경우는 몇 번?</p><p>문제 자세히 보기: <a href="http://euler.synap.co.kr/prob_detail.php?id=19">[국어]</a> <a href="https://projecteuler.net/problem=19">[영어]</a></p></blockquote><p>Java에서 제공하는 <code>Calendar</code>를 사용하면 쉽게 답을 구할 수 있다. 그러나 <code>Calender</code>는 가변객체(mutable object)인데다 클래스도 잘못 설계되어 있어 코드 모양이 어그러진다. Java 8부터는 거지 같은 <code>Calendar</code> 대신 <code>LocalDate</code>를 사용할 수 있다. <code>LocalDate</code>는 값 객체로 Clojure에서 사용해도 코드가 어그러지지 않는다. 조금 더 생각하면 라이브러리의 도움을 받지 않고도 풀 수 있다.</p><h2 id=방법-1-calendar-사용>방법 1: Calendar 사용</h2><p><code>Calendar</code> 인스턴스를 얻은 다음 연도를 1901년부터 2000년까지, 달을 0(1월)부터 11(12월)까지 바꿔가면서 각 달의 1일이 일요일인 경우에만 <code>[year month 1]</code>을 만든다. 편의상 <code>[year month 1]</code>을 썼지만, 값을 확인하지 않고 <code>count</code>만 하므로 <code>1</code> 또는 <code>:x</code>와 같이 아무 값이나 넣어도 상관 없다. <code>(for ...)</code>를 실행한 결과 시퀀스를 <code>count</code> 하면 답을 구할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn </span><span class=nv>solve1</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>cal</span> <span class=p>(</span><span class=nf>Calendar/getInstance</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>count </span><span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>year</span> <span class=p>(</span><span class=nb>range </span><span class=mi>1901</span> <span class=mi>2001</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=nv>month</span> <span class=p>(</span><span class=nb>range </span><span class=mi>0</span> <span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=ss>:when</span> <span class=p>(</span><span class=nb>= </span><span class=nv>Calendar/SUNDAY</span> <span class=p>(</span><span class=k>do </span><span class=p>(</span><span class=k>. </span><span class=nv>cal</span> <span class=nb>set </span><span class=nv>year</span> <span class=nv>month</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                              <span class=p>(</span><span class=k>. </span><span class=nv>cal</span> <span class=nb>get </span><span class=nv>Calendar/DAY_OF_WEEK</span><span class=p>)))]</span>
</span></span><span class=line><span class=cl>             <span class=p>[</span><span class=nv>year</span> <span class=nv>month</span> <span class=mi>1</span><span class=p>]))))</span>
</span></span></code></pre></div><p><code>Calendar</code>는 가변객체이므로 하나의 인스턴스에 값을 계속 설정하면서 조건에 맞는 경우만 값이 나오도록 했다. 인터페이스가 유창하지(fluent) 않으므로 연-월-일을 설정한 다음 요일을 얻기 위해 <code>(do ...)</code>를 사용했다. 보기 좋은 코드는 아니다.</p><h2 id=방법-2-localdate-사용>방법 2: LocalDate 사용</h2><p><code>LocalDate</code>는 Java 8에서 추가된 새로운 날짜/시간 관련 클래스다. 기존의 <code>Date</code>나 <code>Calendar</code>와 달리 값 객체이므로 인스턴스에 어떤 연산을 하면 새로운 객체가 리턴된다. 기본 로직은 <code>Calendar</code>를 사용했을 때와 동일하다. <code>Calendar</code>를 사용했을 때보다 훨씬 나아졌다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn </span><span class=nv>solve2</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>base</span> <span class=p>(</span><span class=nf>LocalDate/of</span> <span class=mi>1901</span> <span class=mi>1</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>-&gt;&gt;</span> <span class=p>(</span><span class=nb>map </span><span class=o>#</span><span class=p>(</span><span class=nf>.plusMonths</span> <span class=nv>base</span> <span class=nv>%</span><span class=p>)</span> <span class=p>(</span><span class=nf>range</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=nb>take-while </span><span class=o>#</span><span class=p>(</span><span class=nb>&lt;= </span><span class=p>(</span><span class=nf>.getYear</span> <span class=nv>%</span><span class=p>)</span> <span class=mi>2000</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=nb>filter </span><span class=o>#</span><span class=p>(</span><span class=nb>= </span><span class=p>(</span><span class=nf>.getDayOfWeek</span> <span class=nv>%</span><span class=p>)</span> <span class=nv>DayOfWeek/SUNDAY</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=nf>count</span><span class=p>))))</span>
</span></span></code></pre></div><h2 id=방법-3-날짜-더하기-직접-구현>방법 3: 날짜 더하기 직접 구현</h2><p><code>Calendar</code>나 <code>LocalDate</code>와 같은 날짜 라이브러리 클래스를 사용하면 문제 풀이가 너무 쉽다. 이런 클래스를 이용해 푸는 것은 출제자의 의도가 아닐 것이다. 라이브러리 도움 없이 문제를 풀어 보자.</p><p>가장 먼저 생각나는 방법은 1900년 1월 1일(월)부터 하루씩 더해가며 조건을 만족하는 날만 뽑아내 세는 것이다. 다만 달마다 날짜 수가 다르고 윤년도 고려해야 한다.</p><p>문제에 윤년의 조건은 다음과 같이 기술되어 있다.</p><blockquote><p>윤년은 연도를 4로 나누어 떨어지는 해를 말한다. 하지만 400으로 나누어 떨어지지 않는 매 100년째는 윤년이 아니며, 400으로 나누어 떨어지면 윤년이다</p></blockquote><p>따라서 어떤 해가 윤년인지 판단하는 함수는 다음과 같이 작성할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn- </span><span class=nv>divisible?</span> <span class=p>[</span><span class=nv>x</span> <span class=nv>n</span><span class=p>]</span> <span class=p>(</span><span class=nb>zero? </span><span class=p>(</span><span class=nf>mod</span> <span class=nv>x</span> <span class=nv>n</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=kd>defn- </span><span class=nv>leap-year?</span> <span class=p>[</span><span class=nv>year</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nf>divisible?</span> <span class=nv>year</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>divisible?</span> <span class=nv>year</span> <span class=mi>400</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>divisible?</span> <span class=nv>year</span> <span class=mi>4</span><span class=p>)))</span>
</span></span></code></pre></div><p>그리고 어떤 달의 날짜 수를 리턴하는 함수는 다음과 같이 작성할 수 있다. 2월은 윤년인 경우는 29, 윤년이 아닌 경우는 28을 리턴해야 한다. 따라서 인자로 연도와 달을 전달해야 한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn- </span><span class=nv>days-in-month</span> <span class=p>[</span><span class=nv>year</span> <span class=nv>month</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=ss>:pre</span> <span class=p>[(</span><span class=nb>&lt;= </span><span class=mi>1</span> <span class=nv>month</span> <span class=mi>12</span><span class=p>)]}</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>cond </span><span class=p>(</span><span class=o>#</span><span class=p>{</span><span class=mi>1</span> <span class=mi>3</span> <span class=mi>5</span> <span class=mi>7</span> <span class=mi>8</span> <span class=mi>10</span> <span class=mi>12</span><span class=p>}</span> <span class=nv>month</span><span class=p>)</span> <span class=mi>31</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>#</span><span class=p>{</span><span class=mi>4</span> <span class=mi>6</span> <span class=mi>9</span> <span class=mi>11</span><span class=p>}</span> <span class=nv>month</span><span class=p>)</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nf>leap-year?</span> <span class=nv>year</span><span class=p>)</span> <span class=mi>29</span>
</span></span><span class=line><span class=cl>        <span class=ss>:else</span> <span class=mi>28</span><span class=p>))</span>
</span></span></code></pre></div><p>이제 주어진 날의 다음 날을 구하는 함수를 작성해보자. 날짜는 <code>vector</code>를 사용해 <code>[year month day-of-month day-of-week]</code>와 같은 형태로 표현하려 한다. 날짜가 해당 월의 마지막 날이면 다음 월로 바꾸고 날짜를 1일로 바꾼다. 마지막 달의 마지막 날(12월31일)이면 연도가 하나 증가하고 날짜는 1월 1일로 바꿔주면 된다. 요일(day-of-week)은 0부터 6까지의 숫자로 나타내며 0은 일요일, 1은 월요일, ..., 6은 토요일이다. 따라서 다음 날을 구하는 함수는 다음과 같이 작성할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn- </span><span class=nv>next-date</span> <span class=p>[[</span><span class=nv>year</span> <span class=nv>month</span> <span class=nv>dm</span> <span class=nv>dw</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>last-day</span> <span class=p>(</span><span class=nf>days-in-month</span> <span class=nv>year</span> <span class=nv>month</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nv>next-dw</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>dw</span><span class=p>]</span> <span class=p>(</span><span class=nf>mod</span> <span class=p>(</span><span class=nb>inc </span><span class=nv>dw</span><span class=p>)</span> <span class=mi>7</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt; </span><span class=nv>dm</span> <span class=nv>last-day</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=nv>year</span> <span class=nv>month</span> <span class=p>(</span><span class=nb>inc </span><span class=nv>dm</span><span class=p>)</span> <span class=p>(</span><span class=nf>next-dw</span> <span class=nv>dw</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt; </span><span class=nv>month</span> <span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=nv>year</span> <span class=p>(</span><span class=nb>inc </span><span class=nv>month</span><span class=p>)</span> <span class=mi>1</span> <span class=p>(</span><span class=nf>next-dw</span> <span class=nv>dw</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=nb>inc </span><span class=nv>year</span><span class=p>)</span> <span class=mi>1</span> <span class=mi>1</span> <span class=p>(</span><span class=nf>next-dw</span> <span class=nv>dw</span><span class=p>)]))))</span>
</span></span></code></pre></div><p>이제 1900년 1월 1일부터 시작해 다음 날을 구해가면서 조건에 맞는 날만 세면 된다. 1900-01-01부터 시작하지만 1901년 1월 1일부터 2000년 12월 31일 사이의 기간 중 매월 1일이 일요일인 경우만 세면 된다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn </span><span class=nv>solve3</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>-&gt;&gt;</span> <span class=p>(</span><span class=nb>iterate </span><span class=nv>next-date</span> <span class=p>[</span><span class=mi>1900</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>drop-while </span><span class=p>(</span><span class=k>fn </span><span class=p>[[</span><span class=nv>year</span> <span class=nv>_</span> <span class=nv>_</span> <span class=nv>_</span><span class=p>]]</span> <span class=p>(</span><span class=nb>&lt;= </span><span class=nv>year</span> <span class=mi>1900</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>take-while </span><span class=p>(</span><span class=k>fn </span><span class=p>[[</span><span class=nv>year</span> <span class=nv>_</span> <span class=nv>_</span> <span class=nv>_</span><span class=p>]]</span> <span class=p>(</span><span class=nb>&lt;= </span><span class=nv>year</span> <span class=mi>2000</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>filter </span><span class=p>(</span><span class=k>fn </span><span class=p>[[</span><span class=nv>_</span> <span class=nv>_</span> <span class=nv>dm</span> <span class=nv>dw</span><span class=p>]]</span> <span class=p>(</span><span class=nb>and </span><span class=p>(</span><span class=nb>= </span><span class=mi>1</span> <span class=nv>dm</span><span class=p>)</span> <span class=p>(</span><span class=nb>zero? </span><span class=nv>dw</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>count</span><span class=p>)))</span>
</span></span></code></pre></div><h2 id=방법-4-월-더하기-직접-구현>방법 4: 월 더하기 직접 구현</h2><p>방법 3과 같이 해도 답을 잘 구한다. 100년이라 해봐야 대략 36,500일고 이 정도 루프는 1초도 안 걸린다. 다만 <code>Calendar</code>나 <code>LocalDate</code>를 사용했을 때는 한 달씩 더했는데 지금은 하루씩 더하는 것은 비효율적이라는 생각이 든다. 한 달씩 더하는 방식으로 개선해보자.</p><p>여기서는 항상 1일만 생각하면 된다. 현재 달 1일의 요일을 알 때 다음 달 1일의 요일을 구하려면 그냥 그 달 날짜 수를 더한 다음 7로 나눈 나머지를 구하면 된다. 따라서 현재 달 1일을 알 때 다음 달 1일을 구하는 함수는 다음과 같이 작성할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn- </span><span class=nv>next-month</span> <span class=p>[[</span><span class=nv>year</span> <span class=nv>month</span> <span class=nv>dm</span> <span class=nv>dw</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>dw</span> <span class=p>(</span><span class=nf>mod</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>dw</span> <span class=p>(</span><span class=nf>days-in-month</span> <span class=nv>year</span> <span class=nv>month</span><span class=p>))</span> <span class=mi>7</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>= </span><span class=nv>month</span> <span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>inc </span><span class=nv>year</span><span class=p>)</span> <span class=mi>1</span> <span class=mi>1</span> <span class=nv>dw</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=nv>year</span> <span class=p>(</span><span class=nb>inc </span><span class=nv>month</span><span class=p>)</span> <span class=mi>1</span> <span class=nv>dw</span><span class=p>])))</span>
</span></span></code></pre></div><p>이 함수를 이용하면 문제를 다음과 같이 풀 수 있다. <code>next-date</code> 대신 <code>next-month</code>를 사용한 것만 빼면 <code>solve3</code>과 동일하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=line><span class=cl><span class=p>(</span><span class=kd>defn </span><span class=nv>solve4</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>-&gt;&gt;</span> <span class=p>(</span><span class=nb>iterate </span><span class=nv>next-month</span> <span class=p>[</span><span class=mi>1900</span> <span class=mi>1</span> <span class=mi>1</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>drop-while </span><span class=p>(</span><span class=k>fn </span><span class=p>[[</span><span class=nv>year</span> <span class=nv>_</span> <span class=nv>_</span> <span class=nv>_</span><span class=p>]]</span> <span class=p>(</span><span class=nb>&lt;= </span><span class=nv>year</span> <span class=mi>1900</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>take-while </span><span class=p>(</span><span class=k>fn </span><span class=p>[[</span><span class=nv>year</span> <span class=nv>_</span> <span class=nv>_</span> <span class=nv>_</span><span class=p>]]</span> <span class=p>(</span><span class=nb>&lt;= </span><span class=nv>year</span> <span class=mi>2000</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nb>filter </span><span class=p>(</span><span class=k>fn </span><span class=p>[[</span><span class=nv>_</span> <span class=nv>_</span> <span class=nv>dm</span> <span class=nv>dw</span><span class=p>]]</span> <span class=p>(</span><span class=nb>and </span><span class=p>(</span><span class=nb>= </span><span class=mi>1</span> <span class=nv>dm</span><span class=p>)</span> <span class=p>(</span><span class=nb>zero? </span><span class=nv>dw</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>count</span><span class=p>)))</span>
</span></span></code></pre></div><h2 id=결과>결과</h2><p>실행 결과는 다음과 같다.</p><pre class=console>
p019=> (do
  #_=>   (time (print "1: " (solve1) "\t"))
  #_=>   (time (print "2: " (solve2) "\t"))
  #_=>   (time (print "3: " (solve3) "\t"))
  #_=>   (time (print "4: " (solve4) "\t")))
1:  ??1     "Elapsed time: 1.614267 msecs"
2:  ??1     "Elapsed time: 7.282205 msecs"
3:  ??1     "Elapsed time: 24.905548 msecs"
4:  ??1     "Elapsed time: 0.741834 msecs"
</pre><p>예상대로 <code>solve3</code>이 가장 느리다. <code>solve4</code>가 다른 방식에 비해 월등히 빠르다는 점이 놀랍다. <code>Calendar</code>나 <code>LocalDate</code>는 날짜 외의 다른 부가정보를 가지고 있어 정수 네 개만 담은 Clojure의 <code>vector</code>보다 무거워서 그런게 아닐까 추측해본다.</p><h2 id=참고>참고</h2><ul><li><a href=https://github.com/ntalbs/euler-clj/blob/mainline/src/p019.clj>프로젝트 오일러 19 풀이 소스 코드</a></li><li><a href=http://stackoverflow.com/questions/1969442/whats-wrong-with-java-date-time-api>What's wrong with Java Date & Time API?</a>
Java의 <code>Date</code>와 <code>Calendar</code> 클래스의 잘못된 점이 잘 정리되어 있다.</li></ul></section><footer class=post-footer><div class="social button-box"><a href=https://twitter.com/share class=twitter-share-button data-show-count=false>Tweet</a>
<a class=twitter-follow-button href=https://twitter.com/ntalbs data-show-count=false>Follow @ntalbs</a>
<script async src=//platform.twitter.com/widgets.js></script></div><nav id=article-nav><a class="article-nav-link-wrap previous" href=/2015/project-euler-020/ id=article-nav-newer>프로젝트 오일러 20</a>
<a class="article-nav-link-wrap next" href=/2015/project-euler-018/ id=article-nav-older>프로젝트 오일러 18</a></nav></footer></article></main><section class=section><div class=container><aside><div id=disqus_thread></div></aside><script type=text/javascript>var disqus_shortname="ntalbs-stuff",permalink="https://ntalbs.github.io/2015/project-euler-019/".replace(/\//g,"/"),disqus_config=function(){this.page.url=permalink,this.page.identifier=permalink};(function(){var e=document,t=e.createElement("script");t.src="https://"+disqus_shortname+".disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=/js/index.js type=text/javascript></script>
<script src=/js/mode.js type=text/javascript></script><footer class=page-bottom><div class=inner><section class=copyright>© 2008-2023 <a href=/about>ntalbs</a></section><section class=poweredby>Powered by <a class=icon-ghost href=https://gohugo.io>Hugo</a></section></div></footer></body></html>