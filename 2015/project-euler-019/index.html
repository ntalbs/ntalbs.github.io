<!DOCTYPE html><html><head><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>프로젝트 오일러 19 | ntalbs&#39; stuff</title><meta name="description" content=""><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="ntalbs' stuff"></head><body class="home-template"><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button> <a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archives">Archives</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></div></div></nav><div id="progress"><div id="bar"></div><div class="container"><div id="scroll-title">프로젝트 오일러 19</div></div></div><header class="site-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header><p class="post-meta"><time datetime="2015-05-14T23:00:00.000Z" itemprop="datePublished">2015-05-15</time> on <a href="/tags/Project-Euler/" style="margin:0 5px">Project-Euler</a><a href="/tags/Clojure/" style="margin:0 5px">Clojure</a></p><h1 class="post-title">프로젝트 오일러 19</h1></header><section class="post-content"><blockquote><p>20세기에서, 매월 1일이 일요일인 경우는 몇 번?<br>문제 자세히 보기: <a href="http://euler.synap.co.kr/prob_detail.php?id=19" target="_blank" rel="external">[국어]</a> <a href="https://projecteuler.net/problem=19" target="_blank" rel="external">[영어]</a></p></blockquote><p>Java에서 제공하는 <code>Calendar</code>를 사용하면 쉽게 답을 구할 수 있다. 그러나 <code>Calender</code>는 가변객체(mutable object)인데다 클래스도 잘못 설계되어 있어 코드 모양이 어그러진다. Java 8부터는 거지 같은 <code>Calendar</code> 대신 <code>LocalDate</code>를 사용할 수 있다. <code>LocalDate</code>는 값 객체로 Clojure에서 사용해도 코드가 어그러지지 않는다. 조금 더 생각하면 라이브러리의 도움을 받지 않고도 풀 수 있다.<a id="more"></a></p><h2 id="방법-1-Calendar-사용"><a href="#방법-1-Calendar-사용" class="headerlink" title="방법 1: Calendar 사용"></a>방법 1: Calendar 사용</h2><p><code>Calendar</code> 인스턴스를 얻은 다음 연도를 1901년부터 2000년까지, 달을 0(1월)부터 11(12월)까지 바꿔가면서 각 달의 1일이 일요일인 경우에만 <code>[year month 1]</code>을 만든다. 편의상 <code>[year month 1]</code>을 썼지만, 값을 확인하지 않고 <code>count</code>만 하므로 <code>1</code> 또는 <code>:x</code>와 같이 아무 값이나 넣어도 상관 없다. <code>(for ...)</code>를 실행한 결과 시퀀스를 <code>count</code> 하면 답을 구할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> solve1 []</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [cal (<span class="name">Calendar/getInstance</span>)]</div><div class="line">    (<span class="name"><span class="builtin-name">count</span></span> (<span class="name"><span class="builtin-name">for</span></span> [year (<span class="name"><span class="builtin-name">range</span></span> <span class="number">1901</span> <span class="number">2001</span>)</div><div class="line">                 month (<span class="name"><span class="builtin-name">range</span></span> <span class="number">0</span> <span class="number">12</span>)</div><div class="line">                 <span class="symbol">:when</span> (<span class="name"><span class="builtin-name">=</span></span> Calendar/SUNDAY (<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">.</span></span> cal set year month <span class="number">1</span>)</div><div class="line">                                              (<span class="name"><span class="builtin-name">.</span></span> cal get Calendar/DAY_OF_WEEK)))]</div><div class="line">             [year month <span class="number">1</span>]))))</div></pre></td></tr></table></figure><p><code>Calendar</code>는 가변객체이므로 하나의 인스턴스에 값을 계속 설정하면서 조건에 맞는 경우만 값이 나오도록 했다. 인터페이스가 유창하지(fluent) 않으므로 연-월-일을 설정한 다음 요일을 얻기 위해 <code>(do ...)</code>를 사용했다. 보기 좋은 코드는 아니다.</p><h2 id="방법-2-LocalDate-사용"><a href="#방법-2-LocalDate-사용" class="headerlink" title="방법 2: LocalDate 사용"></a>방법 2: LocalDate 사용</h2><p><code>LocalDate</code>는 Java 8에서 추가된 새로운 날짜/시간 관련 클래스다. 기존의 <code>Date</code>나 <code>Calendar</code>와 달리 값 객체이므로 인스턴스에 어떤 연산을 하면 새로운 객체가 리턴된다. 기본 로직은 <code>Calendar</code>를 사용했을 때와 동일하다. <code>Calendar</code>를 사용했을 때보다 훨씬 나아졌다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> solve2 []</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [base (<span class="name">LocalDate/of</span> <span class="number">1901</span> <span class="number">1</span> <span class="number">1</span>)]</div><div class="line">    (<span class="name"><span class="builtin-name">-&gt;&gt;</span></span> (<span class="name"><span class="builtin-name">map</span></span> #(<span class="name">.plusMonths</span> base %) (<span class="name"><span class="builtin-name">range</span></span>))</div><div class="line">         (<span class="name"><span class="builtin-name">take-while</span></span> #(<span class="name"><span class="builtin-name">&lt;=</span></span> (<span class="name">.getYear</span> %) <span class="number">2000</span>))</div><div class="line">         (<span class="name"><span class="builtin-name">filter</span></span> #(<span class="name"><span class="builtin-name">=</span></span> (<span class="name">.getDayOfWeek</span> %) DayOfWeek/SUNDAY))</div><div class="line">         (<span class="name"><span class="builtin-name">count</span></span>))))</div></pre></td></tr></table></figure><h2 id="방법-3-날짜-더하기-직접-구현"><a href="#방법-3-날짜-더하기-직접-구현" class="headerlink" title="방법 3: 날짜 더하기 직접 구현"></a>방법 3: 날짜 더하기 직접 구현</h2><p><code>Calendar</code>나 <code>LocalDate</code>와 같은 날짜 라이브러리 클래스를 사용하면 문제 풀이가 너무 쉽다. 이런 클래스를 이용해 푸는 것은 출제자의 의도가 아닐 것이다. 라이브러리 도움 없이 문제를 풀어 보자.</p><p>가장 먼저 생각나는 방법은 1900년 1월 1일(월)부터 하루씩 더해가며 조건을 만족하는 날만 뽑아내 세는 것이다. 다만 달마다 날짜 수가 다르고 윤년도 고려해야 한다.</p><p>문제에 윤년의 조건은 다음과 같이 기술되어 있다.</p><blockquote><p>윤년은 연도를 4로 나누어 떨어지는 해를 말한다. 하지만 400으로 나누어 떨어지지 않는 매 100년째는 윤년이 아니며, 400으로 나누어 떨어지면 윤년이다</p></blockquote><p>따라서 어떤 해가 윤년인지 판단하는 함수는 다음과 같이 작성할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn-</span></span> divisible? [x n] (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name"><span class="builtin-name">mod</span></span> x n)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn-</span></span> leap-year? [year]</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">divisible?</span> year <span class="number">100</span>)</div><div class="line">    (<span class="name">divisible?</span> year <span class="number">400</span>)</div><div class="line">    (<span class="name">divisible?</span> year <span class="number">4</span>)))</div></pre></td></tr></table></figure><p>그리고 어떤 달의 날짜 수를 리턴하는 함수는 다음과 같이 작성할 수 있다. 2월은 윤년인 경우는 29, 윤년이 아닌 경우는 28을 리턴해야 한다. 따라서 인자로 연도와 달을 전달해야 한다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn-</span></span> days-in-month [year month]</div><div class="line">  &#123;<span class="symbol">:pre</span> [(<span class="name"><span class="builtin-name">&lt;=</span></span> <span class="number">1</span> month <span class="number">12</span>)]&#125;</div><div class="line">  (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name">#</span>&#123;<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span>&#125; month) <span class="number">31</span></div><div class="line">        (<span class="name">#</span>&#123;<span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">11</span>&#125; month) <span class="number">30</span></div><div class="line">        (<span class="name">leap-year?</span> year) <span class="number">29</span></div><div class="line">        <span class="symbol">:else</span> <span class="number">28</span>))</div></pre></td></tr></table></figure><p>이제 주어진 날의 다음 날을 구하는 함수를 작성해보자. 날짜는 <code>vector</code>를 사용해 <code>[year month day-of-month day-of-week]</code>와 같은 형태로 표현하려 한다. 날짜가 해당 월의 마지막 날이면 다음 월로 바꾸고 날짜를 1일로 바꾼다. 마지막 달의 마지막 날(12월31일)이면 연도가 하나 증가하고 날짜는 1월 1일로 바꿔주면 된다. 요일(day-of-week)은 0부터 6까지의 숫자로 나타내며 0은 일요일, 1은 월요일, …, 6은 토요일이다. 따라서 다음 날을 구하는 함수는 다음과 같이 작성할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn-</span></span> next-date [[year month dm dw]]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [last-day (<span class="name">days-in-month</span> year month)</div><div class="line">        next-dw (<span class="name"><span class="builtin-name">fn</span></span> [dw] (<span class="name"><span class="builtin-name">mod</span></span> (<span class="name"><span class="builtin-name">inc</span></span> dw) <span class="number">7</span>))]</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> dm last-day)</div><div class="line">      [year month (<span class="name"><span class="builtin-name">inc</span></span> dm) (<span class="name">next-dw</span> dw)]</div><div class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> month <span class="number">12</span>)</div><div class="line">        [year (<span class="name"><span class="builtin-name">inc</span></span> month) <span class="number">1</span> (<span class="name">next-dw</span> dw)]</div><div class="line">        [(<span class="name"><span class="builtin-name">inc</span></span> year) <span class="number">1</span> <span class="number">1</span> (<span class="name">next-dw</span> dw)]))))</div></pre></td></tr></table></figure><p>이제 1900년 1월 1일부터 시작해 다음 날을 구해가면서 조건에 맞는 날만 세면 된다. 1900-01-01부터 시작하지만 1901년 1월 1일부터 2000년 12월 31일 사이의 기간 중 매월 1일이 일요일인 경우만 세면 된다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> solve3 []</div><div class="line">  (<span class="name"><span class="builtin-name">-&gt;&gt;</span></span> (<span class="name"><span class="builtin-name">iterate</span></span> next-date [<span class="number">1900</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</div><div class="line">       (<span class="name"><span class="builtin-name">drop-while</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [[year _ _ _]] (<span class="name"><span class="builtin-name">&lt;=</span></span> year <span class="number">1900</span>)))</div><div class="line">       (<span class="name"><span class="builtin-name">take-while</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [[year _ _ _]] (<span class="name"><span class="builtin-name">&lt;=</span></span> year <span class="number">2000</span>)))</div><div class="line">       (<span class="name"><span class="builtin-name">filter</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [[_ _ dm dw]] (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">1</span> dm) (<span class="name"><span class="builtin-name">zero?</span></span> dw))))</div><div class="line">       (<span class="name"><span class="builtin-name">count</span></span>)))</div></pre></td></tr></table></figure><h2 id="방법-4-월-더하기-직접-구현"><a href="#방법-4-월-더하기-직접-구현" class="headerlink" title="방법 4: 월 더하기 직접 구현"></a>방법 4: 월 더하기 직접 구현</h2><p>방법 3과 같이 해도 답을 잘 구한다. 100년이라 해봐야 대략 36,500일고 이 정도 루프는 1초도 안 걸린다. 다만 <code>Calendar</code>나 <code>LocalDate</code>를 사용했을 때는 한 달씩 더했는데 지금은 하루씩 더하는 것은 비효율적이라는 생각이 든다. 한 달씩 더하는 방식으로 개선해보자.</p><p>여기서는 항상 1일만 생각하면 된다. 현재 달 1일의 요일을 알 때 다음 달 1일의 요일을 구하려면 그냥 그 달 날짜 수를 더한 다음 7로 나눈 나머지를 구하면 된다. 따라서 현재 달 1일을 알 때 다음 달 1일을 구하는 함수는 다음과 같이 작성할 수 있다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn-</span></span> next-month [[year month dm dw]]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [dw (<span class="name"><span class="builtin-name">mod</span></span> (<span class="name"><span class="builtin-name">+</span></span> dw (<span class="name">days-in-month</span> year month)) <span class="number">7</span>)]</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> month <span class="number">12</span>)</div><div class="line">      [(<span class="name"><span class="builtin-name">inc</span></span> year) <span class="number">1</span> <span class="number">1</span> dw]</div><div class="line">      [year (<span class="name"><span class="builtin-name">inc</span></span> month) <span class="number">1</span> dw])))</div></pre></td></tr></table></figure><p>이 함수를 이용하면 문제를 다음과 같이 풀 수 있다. <code>next-date</code> 대신 <code>next-month</code>를 사용한 것만 빼면 <code>solve3</code>과 동일하다.</p><figure class="highlight clojure"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> solve4 []</div><div class="line">  (<span class="name"><span class="builtin-name">-&gt;&gt;</span></span> (<span class="name"><span class="builtin-name">iterate</span></span> next-month [<span class="number">1900</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</div><div class="line">       (<span class="name"><span class="builtin-name">drop-while</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [[year _ _ _]] (<span class="name"><span class="builtin-name">&lt;=</span></span> year <span class="number">1900</span>)))</div><div class="line">       (<span class="name"><span class="builtin-name">take-while</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [[year _ _ _]] (<span class="name"><span class="builtin-name">&lt;=</span></span> year <span class="number">2000</span>)))</div><div class="line">       (<span class="name"><span class="builtin-name">filter</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [[_ _ dm dw]] (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">1</span> dm) (<span class="name"><span class="builtin-name">zero?</span></span> dw))))</div><div class="line">       (<span class="name"><span class="builtin-name">count</span></span>)))</div></pre></td></tr></table></figure><h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><p>실행 결과는 다음과 같다.</p><pre class="console">
p019=> (do
  #_=>   (time (print "1: " (solve1) "\t"))
  #_=>   (time (print "2: " (solve2) "\t"))
  #_=>   (time (print "3: " (solve3) "\t"))
  #_=>   (time (print "4: " (solve4) "\t")))
1:  ??1     "Elapsed time: 1.614267 msecs"
2:  ??1     "Elapsed time: 7.282205 msecs"
3:  ??1     "Elapsed time: 24.905548 msecs"
4:  ??1     "Elapsed time: 0.741834 msecs"
</pre><p>예상대로 <code>solve3</code>이 가장 느리다. <code>solve4</code>가 다른 방식에 비해 월등히 빠르다는 점이 놀랍다. <code>Calendar</code>나 <code>LocalDate</code>는 날짜 외의 다른 부가정보를 가지고 있어 정수 네 개만 담은 Clojure의 <code>vector</code>보다 무거워서 그런게 아닐까 추측해본다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/ntalbs/euler/blob/master/src/p019.clj" target="_blank" rel="external">프로젝트 오일러 19 풀이 소스 코드</a></li><li><a href="http://stackoverflow.com/questions/1969442/whats-wrong-with-java-date-time-api" target="_blank" rel="external">What’s wrong with Java Date &amp; Time API?</a><br>Java의 <code>Date</code>와 <code>Calendar</code> 클래스의 잘못된 점이 잘 정리되어 있다.</li></ul></section><footer class="post-footer"><nav id="article-nav"><a href="/2015/project-euler-018/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title">프로젝트 오일러 18</span> </a><a href="/2015/project-euler-020/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">프로젝트 오일러 20</span></a></nav><section id="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></footer></article></main><footer class="site-footer"><div class="inner"><section class="copyright">&copy; 2008-2015 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="http://hexo.io">Hexo</a></section></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script type="text/javascript" src="/js/jquery.fitvids.js"></script><script type="text/javascript" src="/js/index.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>!function(e,a,t,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=a.createElement(t),o=a.getElementsByTagName(t)[0],s.async=1,s.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(s,o)}(window,document,"script",0,"ga"),ga("create","UA-2098194-3","auto"),ga("require","displayfeatures"),ga("send","pageview")</script><script type="text/javascript">var disqus_shortname="ntalbs-stuff";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>