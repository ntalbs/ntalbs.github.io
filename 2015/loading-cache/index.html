<!DOCTYPE html><html><head><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Guava Cache 제대로 사용하기 | ntalbs&#39; stuff</title><meta name="description" content=""><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="ntalbs' stuff"></head><body class="home-template"><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button> <a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archives">Archives</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></div></div></nav><div id="progress"><div id="bar"></div><div class="container"><div id="scroll-title">Guava Cache 제대로 사용하기</div></div></div><header class="site-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header><p class="post-meta"><time datetime="2015-06-09T23:00:00.000Z" itemprop="datePublished">2015-06-10</time> on <a href="/tags/Java/">Java</a></p><h1 class="post-title">Guava Cache 제대로 사용하기</h1></header><section class="post-content"><p><a href="https://code.google.com/p/guava-libraries/wiki/CachesExplained" target="_blank" rel="external">Google Guava Cache</a>는 캐시를 쉽게 사용할 수 있도록 다양한 기능을 제공한다. 간단한 코드로 캐시 크기, 캐시 시간, 데이터 로딩 방법, 데이터 리프레시 방법 등을 제어할 수 있다. 회사에서도 성능 향상을 위해 Guava 캐시가 널리 사용되고 있는데, 최근 캐시 관련 코드를 보다가 이상한 점을 발견했다.<a id="more"></a></p><p>Guava 캐시는 <code>CacheBuilder</code>를 이용해 쉽게 만들 수 있다. <code>LoadingCache</code>를 사용하면 <code>CacheLoader</code>의 <code>load</code>와 <code>loadAll</code> 메서드를 오버라이드해 데이터 로딩 방법을 지정할 수 있다. 그런데 회사 코드에서 캐시를 사용하는 부분은 거의 대부분 다음과 같은 패턴으로 작성되어 있었다. 여기서는 <code>Product</code> 객체를 캐시하며, 원천 데이터는 <code>productService</code>로부터 가져온다고 가정하자.</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Cache&lt;Key, Product&gt; productCache = CacheBuilder.newBuilder()</div><div class="line">    .maximumSize(MAX_SIZE)</div><div class="line">    .expireAfterWrite(DURATION, TimeUnit.MINUTES)</div><div class="line">    .build();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line">  reloadIfNecessary(Lists.newArrayList(key));</div><div class="line">  <span class="keyword">return</span> productCache.getIfPresent(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">getProducts</span><span class="params">(List&lt;Key&gt; keys)</span> </span>&#123;</div><div class="line">  reloadIfNecessary(keys);</div><div class="line">  List&lt;Product&gt; products = Lists.newArrayList();</div><div class="line">  <span class="keyword">for</span> (Key key : keys) &#123;</div><div class="line">    Product p = productCache.getIfPresent(key);</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">      products.add(p);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> products;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Product</code> 객체를 얻기 전에 항상 <code>reloadIfNecessary</code>를 호출한다. <code>reloadIfNecessary</code>는 다음과 같이 구현되어 있다.</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reloadIfNecessary</span><span class="params">(List&lt;Key&gt; keys)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    List&lt;Product&gt; toReload = Lists.newArrayList();</div><div class="line">    <span class="keyword">for</span> (Key key : keys) &#123;</div><div class="line">      <span class="keyword">if</span> (productCache.getIfPresent(key) == <span class="keyword">null</span>) &#123;</div><div class="line">        toReload.add(key);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(toReload)) &#123;</div><div class="line">      List&lt;Product&gt; products = productService.findByIds(toReload);</div><div class="line">      productCache.putAll(Maps.uniqueIndex(products, Product.keyFunc));</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Reload product-cache exception : "</span> + e.getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>reloadIfNecessary</code> 메서드가 하는 일은, 요청한 키 목록에 대한 아이템이 캐시에 있는지 살펴보고 없는 키에 대해서는 다른 서비스를 통해 아이템을 구해 캐시에 채워 넣는 것이다.</p><p>왜 이렇게 했을까? 캐시에 없는 데이터를 캐시로 로드하는 기능은 <code>LoadingCache</code>에 있는 기능이다. 이와 동일한 코드가 <code>LoadingCache</code>에 이미 있으므로 위 코드는 불필요하다. 단지 캐시를 생성할 때 <code>CacheLoader</code>를 만들어 넣어주면 된다.</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> LoadingCache&lt;Key, Product&gt; productCache = CacheBuilder.newBuilder()</div><div class="line">    .maximumSize(MAX_SIZE)</div><div class="line">    .expireAfterWrite(DURATION, TimeUnit.MINUTES)</div><div class="line">    .build(<span class="keyword">new</span> CacheLoader&lt;Key, Product&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Product <span class="title">load</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> productService.findById(key);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Map&lt;Key, Product&gt; <span class="title">loadAll</span><span class="params">(Iterable&lt;? extends Key&gt; keys)</span> </span>&#123;</div><div class="line">        List&lt;Product&gt; products = productService.findByIds(keys);</div><div class="line">        <span class="keyword">return</span> Maps.uniqueIndex(products, Product.keyFunc);</div><div class="line">      &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure><p><code>LoadingCache</code>에서 <code>get</code> 또는 <code>getAll</code> 메서드를 통해 아이템을 얻으려 할 때 해당 아이템이 없으면 <code>load</code> 또는 <code>loadAll</code> 메서드가 호출되어 캐이에 데이터를 채울 것이다. <code>loadAll</code>은 리턴 타입이 <code>Map&lt;Key, Product&gt;</code>인데 <code>productService.findByIds</code>의 리턴 타입은 <code>List&lt;Product&gt;</code>기 때문에 변환을 위한 코드가 추가되었다. <code>Product.keyFunc</code>는 <code>Product</code>로부터 <code>Key</code>를 얻는 함수(Guava의 <code>Function</code>)다.</p><p>이제 <code>getProduct</code>와 <code>getProducts</code>도 다음과 같이 수정할 수 있다.</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> productCache.getUnchecked(key);</div><div class="line">  &#125; <span class="keyword">catch</span> (ExecuteException x) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Map&lt;Key, Product&gt; <span class="title">getProducts</span><span class="params">(Iterable&lt;Key&gt; keys)</span> <span class="keyword">throws</span> ExecuteException </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> Map&lt;Key, Product&gt; m = productCache.getAll(keys);</div><div class="line">  &#125; <span class="keyword">catch</span> (ExecuteException x) &#123;</div><div class="line">    <span class="keyword">return</span> productCache.getAllPresent(keys);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>코드가 훨씬 단순해 졌다. 길이만 짧아진게 아니라 이해하기도 쉬워졌다. 수정 전의 코드는 길이도 길었을뿐 아니라 쓸데없는 잡음으로 이해하기도 어려웠다.</p><p>참고로, <code>getProducts</code>의 파라미터 타입을 <code>List&lt;Key&gt;</code>에서 <code>Iterable&lt;Key&gt;</code>로, 리턴 타입은 <code>List&lt;Product&gt;</code>에서 <code>Map&lt;Key, Product&gt;</code>로 바꾸었다. 파라미터 타입을 바꾼 이유는 <code>LoadingCache.getAll</code> 메서드의 파라미터 타입과 맞추기 위해서다. <code>getAll</code> 메서드가 <code>Iterable&lt;Key&gt;</code>을 파라미터로 받을 수 있는데 <code>getProducts</code>의 파라미터를 <code>List&lt;Key&gt;</code>로 제한할 필요는 없어 보인다. 물론 <code>getProducts</code>를 호출할 때 <code>List&lt;Key&gt;</code>를 전달하는 것은 가능하다.</p><p>또한 파라미터로 여러 개의 <code>Key</code>를 전달했는데 <code>Product</code>의 목록만 리턴하는 것 보다는 <code>Key</code>-<code>Product</code> 맵으로 리턴하는 것이 더 합당해 보인다. 상황에 따라 이렇게 마음대로 인터페이스를 바꾸는 게 불가능할 수도 있다. 인터페이스를 바꾸는 게 좋을지 유지하는게 좋을지 판단은 각자의 몫이다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>라이브러리를 사용하기로 했다면 최소한 해당 라이브러리의 사용 방법과 API를 미리 확인해야 한다. 제대로 확인하지 않고 라이브러리에 이미 있는 기능을 다시 구현하는 것은 바보 같은 짓이다. 코드만 길어지는 게 아니라 불필요한 잡음을 추가해 코드의 가독성을 떨어뜨리고 유지보수를 어렵게 만든다.</p><div class="button-box"><a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a> <a class="twitter-follow-button" href="https://twitter.com/ntalbs" data-show-count="false">Follow @ntalbs</a></div></section><footer class="post-footer"><nav id="article-nav"><a href="/2015/if-cond-condp-case/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title">if, cond, condp, case</span> </a><a href="/2015/project-euler-020/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">프로젝트 오일러 20</span></a></nav><section id="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></footer></article></main><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><footer class="site-footer"><div class="inner"><section class="copyright">&copy; 2008-2018 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="http://hexo.io">Hexo</a></section></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script type="text/javascript" src="/js/jquery.fitvids.js"></script><script type="text/javascript" src="/js/index.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [ ['$','$'], ["\\(","\\)"] ],
     processEscapes: true
   }
 });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
   tex2jax: {
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
   }
 });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
   var all = MathJax.Hub.getAllJax(), i;
   for(i=0; i < all.length; i += 1) {
     all[i].SourceElement().parentNode.className += ' has-jax';
   }
 });</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?..."></script><script>!function(e,a,t,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=a.createElement(t),o=a.getElementsByTagName(t)[0],s.async=1,s.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(s,o)}(window,document,"script",0,"ga"),ga("create","UA-2098194-3","auto"),ga("require","displayfeatures"),ga("send","pageview")</script><script type="text/javascript">var disqus_shortname="ntalbs-stuff";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [ ['$','$'], ["\\(","\\)"] ],
     processEscapes: true
   }
 });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
   tex2jax: {
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
   }
 });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
   var all = MathJax.Hub.getAllJax(), i;
   for(i=0; i < all.length; i += 1) {
     all[i].SourceElement().parentNode.className += ' has-jax';
   }
 });</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?..."></script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>