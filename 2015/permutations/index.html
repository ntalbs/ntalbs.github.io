<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>순열 구하기 @ntalbs&#39; stuff</title>
<link rel="shortcut icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">


  </head>
  <body>
    <div id="progress">
  <div id="bar"></div>
  <div class="container">
    <div id="scroll-title">순열 구하기</div>
  </div>
</div>

    <nav class="navbar" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button>
      <a class="navbar-brand" href="/">@ntalbs&#39; stuff</a>
    </div>
    <div class="navbar-items collapsed" id="nav-items">
      <ul>
        
        <li><a href="/archive">Archive</a></li>
        
        <li><a href="/tags">Tags</a></li>
        
        <li><a href="/about">About</a></li>
        
      </ul>
    </div>
  </div>
</nav>

<header class="page-head">
  <div class="container">
    <p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p>
  </div>
</header>

    <main class="container" role="main">
      <article class="post">
        <header>
          <p class="post-meta">
            <time datetime="2015-07-17" itemprop="datePublished">2015-07-17</time>
            on
            
            <a href="/tags/%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98">알고리즘</a>
            
            <a href="/tags/clojure">Clojure</a>
            
          </p>
          <h1 class="post-title">
            순열 구하기
          </h1>
        </header>
        <section class="post-content">
          <p><a href="/2015/project-euler-024/">프로젝트 오일러 24번</a>은 <code>clojure.math.combinatorics</code>에 있는 <code>nth-permutation</code>을 이용해 문제를 너무 쉽게 풀었다. 그런데 순열을 직접 구하려면 어떻게 해야 할까?</p>

<h2 id="알고리즘">알고리즘</h2>

<p>한참 동안 고민한 끝에 다음과 같은 알고리즘을 생각해냈다.</p>

<ol>
<li>요소가 한 개 뿐일 때는 순열도 하나 뿐이다.
<code>[1]</code> &#8594; <code>[1]</code></li>
<li>요소가 두 개일 때는 두 개의 순열이 생긴다.
<code>[1 2]</code> &#8594; <code>([1 2] [2 1])</code></li>
<li>요소가 세 개일 때: 첫 번째 요소를 꺼내면 남는 요소가 두 개가 된다. 선택한 요소를 맨 앞에 두고 나머지 두 요소의 순열을 구해 선택한 요소 뒤에 연결한다. 두 번째 요소, 세 번째 요소를 선택해 같은 작업을 반복한다.</li>
<li>요소가 $n$개일 때: 요소 하나를 꺼내면 남는 요소가 $(n-1)$개가 된다. 선택한 요소를 맨 앞에 두고 나머지 $(n-1)$개 요소의 순열을 구해 선택한 요소 뒤에 연결한다. 나머지 요소에 대해 같은 작업을 반복한다.</li>
</ol>

<p>3, 4에 대해서는 예를 들어 설명하는 것이 좋겠다. <code>[1, 2, 3]</code>의 순열을 구하는 경우는 <code>[1]</code> + <code>[2 3]</code>과 같이 나눈 다음 <code>[2 3]</code>에 대한 순열을 구해 <code>[1]</code>과 합친다. <code>[2 3]</code>에 대한 순열은 단계 2에서 설명한 것과 같이 <code>([2 3] [3 2])</code>두 가지가 나온다. 따라서 <code>[2 3]</code>의 각 순열에 <code>[1]</code>을 합치면 <code>([1 2 3] [1 3 2])</code>가 된다. 나머지 요소 2, 3에 대해서도 같은 작업을 할 수 있다. 2에 대해서는 <code>([2 1 3] [2 3 1])</code>이 나오고 3에 대해서는 <code>([3 1 2] [3 2 1])</code>이 나온다. 이 결과를 모두 합치면 <code>([1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1])</code>이 될 것이다.</p>

<p>요소가 네 개라면 각 요소를 하나씩 선택하고 나머지 세 요소에 대한 순열을 구한 다음 앞에 선택했던 요소 뒤에 붙여주면 된다. 예를 들어 <code>[1 2 3 4]</code>에 대한 순열을 구하려면 <code>[1] + 순열[2 3 4]</code>, <code>[2] + 순열[1 3 4]</code>, <code>[3] + 순열[1 2 4]</code>, <code>[4] + 순열 [1 2 3]</code>을 구해 합치면 된다.</p>

<h2 id="구현">구현</h2>

<p>위에서 설명한 로직은 Clojure로 다음과 같이 구현할 수 있다. 먼저 인자로 리스트를 받는다고 가정하면, 주어진 리스트에서 요소를 하나씩 뽑아 맨 앞으로 재배치한 결과의 목록을 리턴하는 함수가 필요하다. 이 함수는 다음과 같이 작성할 수 있다. 함수 이름이 마음에 들지 않지만 더 좋은 이름을 생각해내지 못했다.</p>

<pre><code class="language-clojure">(defn- picks [coll]
  (for [i (range (count coll))]
    (let [f (take i coll) b (drop i coll)]
      (concat (take 1 b) f (rest b)))))
</code></pre>

<p>이 함수에 <code>[1 2 3]</code>을 전달하면 <code>((1 2 3) (2 1 3) (3 1 2))</code>를 리턴할 것이다.</p>

<p>이제 순열을 구하는 함수를 작성할 차례다. 인자로 주어진 리스트의 길이가 1 또는 2인 경우는 바로 순열을 구할 수 있다. 3 이상인 경우는 리스트 길이를 줄여가며 재귀 호출하게 된다. 재귀 호출을 하면서 리턴하는 리스트가 중첩되지 않도록 하기 위해 인자를 둘로 나누었다. <code>front</code>는 구한 순열(리스트)을, <code>back</code>은 순열을 구할 리스트를 나타낸다.</p>

<pre><code class="language-clojure">(defn- perms [front back]
  (condp = (count back)
    1 (list back)
    2 (list (concat front back)
            (concat front (reverse back)))
    (mapcat
     (fn [ps]
       (perms (concat front (take 1 ps)) (rest ps)))
     (picks back))))
</code></pre>

<p>순열을 구하는 함수 <code>permutations</code>는 다음과 같이 작성할 수 있다. 핵심 로직은 위에서 구현한 <code>picks</code>와 <code>perms</code>에 있고 <code>permutations</code>는 외부에서 사용하기 위한 인터페이스일 뿐이다. <code>perms</code>를 호출할 때 <code>front</code>의 값으로 빈 벡터를 전달한다.</p>

<pre><code class="language-clojure">(defn permutations [xs]
  (perms [] xs))
</code></pre>

<p>기능 하나가 여러 함수로 되어 있으면 보기 좋지 않으므로 <code>picks</code>와 <code>perms</code>를 다음과 같이 내부 함수로 만들면 코드가 깔끔해진다.</p>

<pre><code class="language-clojure">(defn permutations [xs]
  (letfn [(picks [coll]
            (for [i (range (count coll))]
              (let [f (take i coll) b (drop i coll)]
                (concat (take 1 b) f (rest b)))))
          (perms [front back]
            (condp = (count back)
              1 (list back)
              2 (list (concat front back)
                      (concat front (reverse back)))
              (mapcat
               (fn [ps]
                 (perms (concat front (take 1 ps)) (rest ps)))
               (picks back))))]
    (perms [] xs)))
</code></pre>

<h2 id="정리">정리</h2>

<p>여기서 구현한 함수는 <code>clojure.math.combinatorics</code>에서 제공하는 <code>permutations</code>(이하 <code>c/permutations</code>)에 비교해 다음과 같은 점에 있어 매우 초보적인 구현이다.</p>

<ul>
<li><strong>게으르지 않다.</strong> 예를 들어 <code>[1 2 3 ... 10]</code>과 같이 제법 긴 리스트의 순열 중 앞 열 개를 구하는 경우 <code>c/permutations</code>는 매우 빠르게 결과를 리턴한다. 여기서 구현한 함수는 먼저 모든 순열을 구한 다음 그 중 열 개를 리턴하게 되어있어 매우 느리다.</li>
<li><strong>요소의 중복을 고려하지 않았다.</strong> 성능을 고려하지 않는다면 그냥 <code>set</code>에 넣어 중복을 제거하는 방법을 생각할 수도 있겠다.</li>
</ul>

<p>여기서 구현한 <code>permutations</code> 함수를 이용하면 해답을 구하는 데 매우 오래 걸린다. 그저 이런 식으로 순열을 구할 수 있다는 것을 확인한 정도에 만족해야 할 것 같다.</p>

<p>나중에 알고 보니 이 로직은 <a href="https://en.wikipedia.org/wiki/Steinhaus–Johnson–Trotter_algorithm">Steinhaus–Johnson–Trotter 알고리즘</a>와 비슷한 것 같다. 그러나 페이지 중간 쯤에 &lsquo;순열을 재귀로 구현하는 것도 가능하지만, <strong>실제 Steinhaus–Johnson–Trotter 알고리즘은 재귀를 사용하지 않고 반복적인 방법으로 순열을 구한다</strong>&lsquo;는 설명이 나온다.</p>

<p>나중에 시간 날 때 Steinhaus–Johnson–Trotter 알고리즘으로 제대로 구현해봐야 겠다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Steinhaus–Johnson–Trotter_algorithm">Steinhaus–Johnson–Trotter 알고리즘</a></li>
</ul>
        </section>
        <footer class="post-footer">
          
          <div class="social button-box">
            
            <a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a>
            <a class="twitter-follow-button" href="https://twitter.com/ntalbs" data-show-count="false">Follow @ntalbs</a>
            <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
            
          </div>
          
          <nav id="article-nav">
            
            <a class="article-nav-link-wrap previous" href="http://ntalbs.github.io/2015/project-euler-025/" id="article-nav-newer"> 프로젝트 오일러 25</a>
            
            
            <a class="article-nav-link-wrap next" href="http://ntalbs.github.io/2015/project-euler-024/" id="article-nav-older"> 프로젝트 오일러 24</a>
            
          </nav>
        </footer>
      </article>
    </main>
    
<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
     var disqus_shortname = 'ntalbs-stuff';
     (function() {
       var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
       dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
       (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


    <section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/clojure.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/sql.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lisp.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-2098194-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src=http://ntalbs.github.io/js/index.js type="text/javascript"></script>

    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$','$']],
     displayMath: [['$$','$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
            extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
 });
</script>

  </body>
</html>
