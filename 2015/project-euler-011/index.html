<!doctype html><html><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-2098194-3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-2098194-3');</script><meta charset=utf-8><meta name=google-site-verification content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta name=viewport content="width=device-width,initial-scale=1"><title>프로젝트 오일러 11 @ntalbs' stuff</title><link rel="shortcut icon" href=/images/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/xcode.css></head><body><div id=progress><div id=bar></div><div class=container><div id=scroll-title>프로젝트 오일러 11</div></div></div><nav class=navbar role=navigation><div class=container><div class=navbar-header><button type=button class="navbar-toggle unselectable" data-toggle=collapse data-target=#nav-items>+</button>
<a class="navbar-brand unselectable" href=/>@ntalbs' stuff</a></div><div class="navbar-items collapsed" id=nav-items><ul><li><a class=unselectable href=/archive/>Archive</a></li><li><a class=unselectable href=/tags/>Tags</a></li><li><a class=unselectable href=/about/>About</a></li></ul></div></div></nav><header class=page-head><div class=container><p class=blog-description>내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class=container role=main><article class=post><header><p class=post-meta><time datetime=2015-03-10 itemprop=datePublished>2015-03-10</time>
on
<a href=/tags/project-euler/>Project-Euler</a>
<a href=/tags/clojure/>Clojure</a></p><h1 class=post-title>프로젝트 오일러 11</h1></header><section class=post-content><blockquote><p>20×20 격자에서 연속된 네 숫자의 곱 중 최대값?</p><p>문제 자세히 보기: <a href="http://euler.synap.co.kr/prob_detail.php?id=11">[국어]</a> <a href="https://projecteuler.net/problem=11">[영어]</a></p></blockquote><p><a href=/2015/project-euler-008/>문제 8</a>에서 살펴봤듯이 <code>partition</code> 함수를 사용하면 연속된 숫자를 네 개씩 묶어낼 수 있다.</p><pre class=console>
user=> (partition 4 1 (range 20))
((0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6 7 8) ...)
</pre><p>문제는 이걸 어떻게 가로(-), 세로(|), 대각선(\), 역대각선(/) 네 방향으로 만들어 내느냐는 것이다. 네 방향으로 숫자 시퀀스를 만들기만 하면 문제를 쉽게 풀 수 있다. 데이터가 다음과 같이 벡터의 벡터(vector of vectors)로 되어 있다고 하자. (vector로 해야 인덱스로 접근할 수 있다.)</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>m</span> <span class=p>[</span><span class=p>[</span> <span class=mi>8</span>  <span class=mi>2</span> <span class=mi>22</span> <span class=mi>97</span> <span class=mi>38</span> <span class=nv>...</span><span class=p>]</span>
        <span class=p>[</span><span class=mi>49</span> <span class=mi>49</span> <span class=mi>99</span> <span class=mi>40</span> <span class=mi>17</span> <span class=nv>...</span><span class=p>]</span>
        <span class=p>[</span><span class=mi>81</span> <span class=mi>49</span> <span class=mi>31</span> <span class=mi>73</span> <span class=mi>55</span> <span class=nv>...</span><span class=p>]</span>
        <span class=p>[</span><span class=mi>52</span> <span class=mi>70</span> <span class=mi>95</span> <span class=mi>23</span>  <span class=mi>4</span> <span class=nv>...</span><span class=p>]</span>
        <span class=p>[</span><span class=mi>22</span> <span class=mi>31</span> <span class=mi>16</span> <span class=mi>71</span> <span class=mi>51</span> <span class=nv>...</span><span class=p>]</span>
        <span class=nv>...</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><p>가로 방향의 시퀀스는 들어 있는 그대로 접근하면 얻을 수 있다.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>horizontal</span> <span class=nv>m</span><span class=p>)</span>
</code></pre></div><p>세로 방향의 시퀀스는 위 행렬의 전치행렬(transposed matrix)을 구하면 된다. 이 또한 다음과 같이 간단히 구할 수 있다.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>vertical</span> <span class=p>(</span><span class=nb>apply </span><span class=nb>map </span><span class=nb>list </span><span class=nv>m</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>대각선 방향으로 시퀀스를 만들려면 조금 생각을 해야 한다. 대각선 방향의 요소에 대한 인덱스를 보면, 처음 시작 열을 <code>c</code>라 할 때 $(0, c), (1, c+1), (2, c+2), ...$와 같이 표현할 수 있다.</p><p><img src=/2015/03-10-project-euler-011/diagonal.png alt></p><p>각 대각선마다 별도 시퀀스를 만들어야 하므로 다음과 같이 중첩 <code>for</code>를 사용해 대각선 요소에 대한 시퀀스를 구할 수 있다. 대각선 아래쪽 삼각형 영역에 위치한 대각선 방향 시퀀스는 시작 열 인덱스를 음수로 하면 얻을 수 있다. 따라서 <code>c</code>의 시작 값은 <code>-rows</code>로 하면 될 듯 하다. 실제로 <code>c</code>가 <code>-rows</code>인 경우는 빈 시퀀스가 되겠지만.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>diagonal</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>rows</span> <span class=p>(</span><span class=nb>count </span><span class=nv>m</span><span class=p>)</span>, <span class=nv>cols</span> <span class=p>(</span><span class=nb>count </span><span class=p>(</span><span class=nb>first </span><span class=nv>m</span><span class=p>)</span><span class=p>)</span><span class=p>]</span>
    <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>c</span> <span class=p>(</span><span class=nb>range </span><span class=p>(</span><span class=nb>- </span><span class=nv>rows</span><span class=p>)</span> <span class=nv>cols</span><span class=p>)</span><span class=p>]</span>
      <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>r</span> <span class=p>(</span><span class=nb>range </span><span class=mi>0</span> <span class=nv>rows</span><span class=p>)</span> <span class=ss>:when</span> <span class=p>(</span><span class=nb>&lt; </span><span class=mi>-1</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>c</span> <span class=nv>r</span><span class=p>)</span> <span class=mi>20</span><span class=p>)</span><span class=p>]</span>
        <span class=p>(</span><span class=nf>get-in</span> <span class=nv>m</span> <span class=p>[</span><span class=nv>r</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>r</span> <span class=nv>c</span><span class=p>)</span><span class=p>]</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>역대각선 방향의 시퀀스도 대각선 방향의 시퀀스와 방향만 다를 뿐 방식은 동일하다. 역대각선 방향에서는 행 인덱스가 늘어날 때마다 열 인덱스는 줄어들어야 한다.</p><p><img src=/2015/03-10-project-euler-011/anti-diagonal.png alt></p><p>여기서는 <code>c</code>의 범위가 <code>0</code> ~ <code>(rows + cols)</code>가 되어야 한다.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>anti-diagonal</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>rows</span> <span class=p>(</span><span class=nb>count </span><span class=nv>m</span><span class=p>)</span>, <span class=nv>cols</span> <span class=p>(</span><span class=nb>count </span><span class=p>(</span><span class=nb>first </span><span class=nv>m</span><span class=p>)</span><span class=p>)</span><span class=p>]</span>
    <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>c</span> <span class=p>(</span><span class=nb>range </span><span class=mi>0</span> <span class=p>(</span><span class=nb>* </span><span class=p>(</span><span class=nb>+ </span><span class=nv>rows</span> <span class=nv>cols</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>]</span>
      <span class=p>(</span><span class=nb>for </span><span class=p>[</span><span class=nv>r</span> <span class=p>(</span><span class=nb>range </span><span class=mi>0</span> <span class=nv>rows</span><span class=p>)</span> <span class=ss>:when</span> <span class=p>(</span><span class=nb>&lt; </span><span class=mi>-1</span> <span class=p>(</span><span class=nb>- </span><span class=nv>c</span> <span class=nv>r</span><span class=p>)</span> <span class=mi>20</span><span class=p>)</span><span class=p>]</span>
        <span class=p>(</span><span class=nf>get-in</span> <span class=nv>m</span> <span class=p>[</span><span class=nv>r</span> <span class=p>(</span><span class=nb>- </span><span class=nv>c</span> <span class=nv>r</span><span class=p>)</span><span class=p>]</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>이제 문제를 거의 다 풀었다. 각 방향에 대한 시퀀스를 구했으므로 이걸 다 합친 다음 네 개씩 묶어서 곱한 값의 최대 값을 구하면 된다. 처음 언급한 바와 같이 <code>partition</code> 함수를 사용하면 이 작업을 간단히 할 수 있다. 대각선 및 역대각선 방향의 시퀀스에서는 아이템 개수가 4개 이하인 시퀀스도 있는데 이런 것들은 <code>partition</code> 함수가 다 걸러주므로 별도로 <code>filter</code>를 쓰지 않아도 된다.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>defn </span><span class=nv>solve</span> <span class=p>[</span><span class=p>]</span>
  <span class=p>(</span><span class=nf>-&gt;&gt;</span> <span class=p>(</span><span class=nb>concat </span><span class=nv>horizontal</span> <span class=nv>vertical</span> <span class=nv>diagonal</span> <span class=nv>anti-diagonal</span><span class=p>)</span>
       <span class=p>(</span><span class=nb>mapcat </span><span class=o>#</span><span class=p>(</span><span class=nf>partition</span> <span class=mi>4</span> <span class=mi>1</span> <span class=nv>%</span><span class=p>)</span><span class=p>)</span>
       <span class=p>(</span><span class=nb>map </span><span class=o>#</span><span class=p>(</span><span class=nb>apply </span><span class=nb>* </span><span class=nv>%</span><span class=p>)</span><span class=p>)</span>
       <span class=p>(</span><span class=nb>apply </span><span class=nv>max</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>결과는 다음과 같다.</p><pre class=console>
p011=> (time (solve))
"Elapsed time: 1.859183 msecs"
706???74
</pre><h2 id=heading>참고</h2><ul><li><a href=https://github.com/ntalbs/euler/blob/master/src/p011.clj>프로젝트 오일러 11 풀이 소스 코드</a></li></ul></section><footer class=post-footer><div class="social button-box"><a href=https://twitter.com/share class=twitter-share-button data-show-count=false>Tweet</a>
<a class=twitter-follow-button href=https://twitter.com/ntalbs data-show-count=false>Follow @ntalbs</a>
<script async src=//platform.twitter.com/widgets.js></script></div><nav id=article-nav><a class="article-nav-link-wrap previous" href=https://ntalbs.github.io/2015/thought-on-korean-education/ id=article-nav-newer>국어 교육에 대해</a>
<a class="article-nav-link-wrap next" href=https://ntalbs.github.io/2015/project-euler-010/ id=article-nav-older>프로젝트 오일러 10</a></nav></footer></article></main><section class=section><div class=container><aside><div id=disqus_thread></div></aside><script type=text/javascript>var disqus_shortname='ntalbs-stuff';(function(){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=https://ntalbs.github.io/js/index.js type=text/javascript></script><footer class=page-bottom><div class=inner><section class=copyright>© 2008-2019 <a href=/about>ntalbs</a></section><section class=poweredby>Powered by <a class=icon-ghost href=https://gohugo.io>Hugo</a></section></div></footer></body></html>