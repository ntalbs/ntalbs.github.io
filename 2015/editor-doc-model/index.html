<!doctype html><html><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-2098194-3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-2098194-3');</script><meta charset=utf-8><meta name=google-site-verification content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta name=viewport content="width=device-width,initial-scale=1"><title>에디터 문서 모델 @ntalbs' stuff</title><link rel="shortcut icon" href=/images/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/highlight.css></head><body><div id=progress><div id=bar></div><div class=container><div id=scroll-title>에디터 문서 모델</div></div></div><nav class=navbar role=navigation><div class=container><div class=navbar-header><button type=button class="navbar-toggle unselectable" data-toggle=collapse data-target=#nav-items>+</button>
<a class="navbar-brand unselectable" href=/>@ntalbs' stuff</a></div><div class="navbar-items collapsed" id=nav-items><ul><li><a class=unselectable href=/archive/>Archive</a></li><li><a class=unselectable href=/tags/>Tags</a></li><li><a class=unselectable href=/about/>About</a></li><li><a id=mode-switch class=unselectable href=#></a></li></ul></div></div></nav><header class=page-head><div class=container><p class=blog-description>내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class=container role=main><article class=post><header><p class=post-meta><time datetime=2015-06-22 itemprop=datePublished>2015-06-22</time>
on
<a href=/tags/%ec%97%90%eb%94%94%ed%84%b0_%ea%b0%9c%eb%b0%9c/>에디터_개발</a></p><h1 class=post-title>에디터 문서 모델</h1></header><section class=post-content><p>복잡한 소프트웨어를 만들 때 여러 번의 갈림길에 서게 된다. 나중에는 쉽게 알 수 있는 사실이라도 선택할 당시에는 명확하지 않아 어느 쪽이 옳은지 판단하기가 쉽지 않은 경우가 많다. 에디터에서 <strong>문서 모델</strong>을 설계할 때도 마찬가지다. 문서 모델은 편집하는 문서를 어떤 구조로 저장하고 조작할지를 결정하는 에디터의 핵심 데이터 구조다. 문서 모델의 구조에 따라 이후 개발할 편집 기능의 구현 방향이 갈릴 것이다. 문서 모델이 잘못되어 있다면 기능 구현은 매우 피곤하고 힘든 과정이 될 수 있다.</p><p>입력기 또는 뷰에서 발생한 이벤트를 받아 모델을 조작하고, 수정된 모델을 기반으로 뷰를 업데이트하는 것이 에디터의 기본 동작 흐름이다. 키보드 이벤트는 입력기를 통해 발생하지만 마우스 이벤트는 뷰에서 발생한다. 따라서 에디터가 잘 동작하려면 모델과 뷰의 매핑이 중요하다. 에디터를 만들면서 빈번하게 발생하는 문제의 대부분이 모델-뷰 매핑 오류에서 비롯된다.</p><p>에디터를 만들면서 내가 생각할 수 있는 문서 모델 구조는 다음 세 가지다. 에디터의 기본 동작 중에서도 가장 기본인 글자 입력/삭제, 단락 추가/분리/삭제 동작을 각 모델에서 어떻게 구현할 수 있을지, 단락 스타일, 글꼴 스타일을 어떻게 표현할 수 있을지 생각해보면 어느 모델을 사용하는 것이 유리할 지 판단하는 데 도움이 된다.</p><h2 id=dom>DOM</h2><p>HTML DOM을 그대로 문서 모델로 사용하는 방법이다. 물론 문서 모델 DOM은 브라우저 화면에 표시될 HTML의 DOM과는 다른 모습이 될 수 있다. 문서 모델의 DOM 트리는 내가 정의한 구조를 유지하도록 할 수 있다. 예를 들어 텍스트 런(run)의 중첩을 허용하지 않는 단순한 구조로 문서 모델을 제한할 수 있다. 이렇게 하면 여러 편집 동작을 구현하는 게 단순해진다.</p><p>예를 들어 문서를 다음과 같이 나타낼 수 있다. 편의상 문서 모델의 루트를 <code>&lt;doc></code>으로, 단락은 <code>&lt;p></code>로, 런은 <code>&lt;r></code>로, 볼드체가 적용된 런은 <code>&lt;b></code>로, 이탤릭체가 적용된 런은 <code>&lt;i></code>로 나타냈다.</p><div class=highlight><pre class=chroma><code class=language-html data-lang=html><span class=p>&lt;</span><span class=nt>doc</span><span class=p></span><span class=p>&gt;</span>
  <span class=p>&lt;</span><span class=nt>p</span><span class=p></span><span class=p>&gt;</span><span class=p>&lt;</span><span class=nt>r</span><span class=p></span><span class=p>&gt;</span>김수한무 <span class=p>&lt;</span><span class=p>/</span><span class=nt>r</span><span class=p>&gt;</span><span class=p>&lt;</span><span class=nt>b</span><span class=p></span><span class=p>&gt;</span>거북이<span class=p>&lt;</span><span class=p>/</span><span class=nt>b</span><span class=p>&gt;</span><span class=p>&lt;</span><span class=nt>r</span><span class=p></span><span class=p>&gt;</span>와<span class=p>&lt;</span><span class=p>/</span><span class=nt>r</span><span class=p>&gt;</span><span class=p>&lt;</span><span class=nt>i</span><span class=p></span><span class=p>&gt;</span>두루미<span class=p>&lt;</span><span class=p>/</span><span class=nt>i</span><span class=p>&gt;</span><span class=p>&lt;</span><span class=p>/</span><span class=nt>p</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=p>/</span><span class=nt>doc</span><span class=p>&gt;</span>
</code></pre></div><p>모델이 HTML 문자열이 아니라 DOM 트리라는 점을 이해하는 것이 중요하다. 실제 HTML에는 <code>&lt;r></code> 태그가 없지만 이렇게 써도 DOM 트리를 구성하고 조작하는 데는 문제가 되지 않는다. DOM을 쓸 때의 장점은 문서를 조작할 때 jQuery나 브라우저에서 제공하는 Range 객체를 사용할 수 있다는 점이다. 반면 뷰 구조에 따라 모델과 뷰를 매핑하는 작업이 까다로워질 수 있다. 예를 들어 에디터에서 페이지 모양의 뷰를 제공하기로 했다면 뷰의 DOM 구조와 모델의 DOM 구조는 완전히 달라지는데 이때 모델과 뷰의 요소를 매핑하는 작업은 단순하지 않다.</p><h2 id=json>JSON</h2><p>문서 모델을 JSON 형식으로 가지고 있으면 JavaScript로 조작하기가 쉬워 보인다. JSON을 읽어 뷰를 만들어 내는 것도 어렵지 않아 보인다. 문서를 단락(paragraph)의 배열로, 위치는 단락과 단락 처음부터의 오프셋으로 나타낼 수 있다. 단락 내 글꼴 스타일은 해당 스타일이 적용될 오프셋 범위로 표현할 수 있다.</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>var</span> <span class=nx>doc</span> <span class=o>=</span> <span class=p>[</span>
  <span class=p>{</span> <span class=nx>text</span><span class=o>:</span> <span class=s2>&#34;김수한무 거북이와 두루미&#34;</span><span class=p>,</span>
    <span class=nx>b</span><span class=o>:</span> <span class=p>{</span> <span class=nx>start</span><span class=o>:</span> <span class=mi>5</span><span class=p>,</span> <span class=nx>end</span><span class=o>:</span> <span class=mi>8</span><span class=p>}</span><span class=p>,</span>
    <span class=nx>i</span><span class=o>:</span> <span class=p>{</span> <span class=nx>start</span><span class=o>:</span> <span class=mi>10</span><span class=p>,</span> <span class=nx>end</span><span class=o>:</span> <span class=mi>12</span><span class=p>}</span>
  <span class=p>}</span>
  <span class=p>...</span>
<span class=p>]</span>
</code></pre></div><p>그러나 JSON을 사용하면 각 스타일의 오프셋을 관리해야 하는 부담이 생긴다. 단락의 맨 앞에 글자를 입력한다고 생각해보자. <code>b</code>와 <code>i</code>의 시작/끝 오프셋을 모두 업데이트 해야 한다. '거북이와' 바로 다음 위치에서 엔터 키를 눌러 단락을 분리한다고 생각해보자. 새로운 단락 객체를 만들어 배열에 추가하고 <code>i</code>의 인덱스를 업데이트해줘야 한다. 이런 작업이 불가능하지는 않겠지만 DOM을 써서 조작할 때보다 복잡하고 생각하기 어려워 질 것 같다.</p><p>단락은 런(run)의 배열로 표현하면 어떨까? 이렇게 하면 매 입력마다 각 런의 오프셋을 업데이트 해야 하는 문제는 없어진다.</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>var</span> <span class=nx>doc</span> <span class=o>=</span> <span class=p>[</span>
  <span class=p>{</span> <span class=nx>pid</span><span class=o>:</span> <span class=s2>&#34;p1&#34;</span><span class=p>,</span>
    <span class=nx>runs</span><span class=o>:</span> <span class=p>[</span>
      <span class=p>{</span> <span class=nx>rid</span><span class=o>:</span> <span class=s2>&#34;p1r1&#34;</span><span class=p>,</span>
        <span class=nx>text</span><span class=o>:</span> <span class=s2>&#34;김수한무 &#34;</span><span class=p>}</span><span class=p>,</span>
      <span class=p>{</span> <span class=nx>rid</span><span class=o>:</span> <span class=s2>&#34;p1r2&#34;</span>
        <span class=nx>style</span><span class=o>:</span> <span class=s2>&#34;bold&#34;</span>
        <span class=nx>text</span><span class=o>:</span> <span class=s2>&#34;거북이와 &#34;</span><span class=p>}</span><span class=p>,</span>
      <span class=p>{</span> <span class=nx>rid</span><span class=o>:</span> <span class=s2>&#34;p1r3&#34;</span>
        <span class=nx>style</span><span class=o>:</span> <span class=s2>&#34;italic&#34;</span>
        <span class=nx>text</span><span class=o>:</span> <span class=s2>&#34;두루미&#34;</span><span class=p>}</span>
    <span class=p>]</span><span class=p>}</span>
  <span class=p>...</span>
<span class=p>]</span>
</code></pre></div><p>단락을 나누는 경우를 생각해보자. '거북이와' 바로 다음 위치에서 엔터 키를 눌러 단락을 분리하는 경우 새로운 단락을 만들어 런을 옮겨주면 된다. 그러나 현재 런으로부터 부모 단락을 얻고, 현재 런 이후의 형제 노드를 얻는 방법이 없다. 런에서 부모 단락을 얻기 위해 각 런에 부모 단락 아이디(<code>pid</code>)를 추가하는 것을 고려할 수 있다. 관리해야 할 속성이 하나 늘어났다. 현재 런 이후의 형제 노드는 어떻게 얻어야 할까? 간단한 방법은 떠오르지 않는다. DOM에서는 모두 쉽게 얻을 수 있는 정보다.</p><p>물론 방법이 있을 것이다. 부모-자식을 쉽게 참조할 수 있도록 속성을 추가하고, 자신의 이전, 이후 런을 쉽게 알 수 있도록 런 인덱스 같은 것을 추가하는 것도 고려할 수 있겠다. 이런 속성을 하나씩 추가할 때마다 각 속성이 올바른 상태를 유지하도록 제어하는 코드가 필요할 것이고 복잡도는 증가할 것이다.</p><p>DOM을 문서 모델로 사용할 때와 마찬가지로, 뷰-모델 매핑 또한 여전히 풀어야 문제다. JSON을 사용한다고 이 문제가 사라지지는 않는다.</p><h2 id=view-as-model>View as Model</h2><p>모델과 뷰의 구조가 동일하다면 뷰를 모델 그대로 사용할 수 없을까? 불가능해 보이지는 않는다. 이 방법은 뷰와 모델을 하나로 가져가는 것이며 뷰는 HTML로 표현할 수밖에 없으므로 결국 모델/뷰는 동일한 HTML DOM으로 표현될 것이다. 편집이 발생해 모델을 수정하면 뷰도 함께 수정되어 별도의 렌더링 단계를 거칠 필요가 없어진다.</p><p>언듯 보면 괜찮은 방안으로 보이지만 제약사항이 있다. 에디터 화면에서 표현해야 하는 기능은 결국 뷰의 마크업으로 나타내야 하는데 이 모델에서는 뷰와 모델이 동일하므로 뷰의 구조가 모델의 구조를 결정하게 된다. 뷰에 나타나는 구조가 데이터를 표현하는 최선의 방법이 아닌 경우 문제가 드러난다.</p><p>간단한 에디터를 만들 때 고려할 수 있는 방안 중 하나라 생각하지만 다양하고 복잡한 기능을 제공하는 에디터를 만들 생각이라면 뷰와 모델을 분리하는 방향을 선택하는 것이 좋다.</p><h2 id=결론>결론</h2><p>각 접근법마다 나름의 장점과 제약사항이 있다. DOM을 문서 모델로 사용하는 에디터는 만들어 봤지만 다른 방식의 모델로 만들어 보지는 않았기 때문에 직접 해보면 다른 특성을 알게 될지도 모르겠다. 현재로선 문서 모델로 DOM을 선택하는 것이 가장 좋아 보인다. 페이지 보기, 다양한 글머리 기호, 다단계 번호매기기 등 HTML의 기본 기능을 넘어선 다양한 기능을 구현하고 싶다면 모델과 뷰를 분리해야 한다.</p></section><footer class=post-footer><div class="social button-box"><a href=https://twitter.com/share class=twitter-share-button data-show-count=false>Tweet</a>
<a class=twitter-follow-button href=https://twitter.com/ntalbs data-show-count=false>Follow @ntalbs</a>
<script async src=//platform.twitter.com/widgets.js></script></div><nav id=article-nav><a class="article-nav-link-wrap previous" href=https://ntalbs.github.io/2015/project-euler-023/ id=article-nav-newer>프로젝트 오일러 23</a>
<a class="article-nav-link-wrap next" href=https://ntalbs.github.io/2015/project-euler-022/ id=article-nav-older>프로젝트 오일러 22</a></nav></footer></article></main><section class=section><div class=container><aside><div id=disqus_thread></div></aside><script type=text/javascript>var disqus_shortname='ntalbs-stuff';(function(){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=https://ntalbs.github.io/js/index.js type=text/javascript></script><script src=https://ntalbs.github.io/js/mode.js type=text/javascript></script><footer class=page-bottom><div class=inner><section class=copyright>© 2008-2020 <a href=/about>ntalbs</a></section><section class=poweredby>Powered by <a class=icon-ghost href=https://gohugo.io>Hugo</a></section></div></footer></body></html>