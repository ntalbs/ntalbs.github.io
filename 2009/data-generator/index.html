<!DOCTYPE html><html><head><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>데이터 생성 SQL | ntalbs&#39; stuff</title><meta name="description" content=""><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="ntalbs' stuff"></head><body class="home-template"><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button> <a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archives">Archives</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></div></div></nav><div id="progress"><div id="bar"></div><div class="container"><div id="scroll-title">데이터 생성 SQL</div></div></div><header class="site-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header><p class="post-meta"><time datetime="2009-04-13T23:00:00.000Z" itemprop="datePublished">2009-04-14</time> on <a href="/tags/DB/">DB</a><a href="/tags/Oracle/">Oracle</a><a href="/tags/SQL/">SQL</a><a href="/tags/PostgreSQL/">PostgreSQL</a></p><h1 class="post-title">데이터 생성 SQL</h1></header><section class="post-content"><p>Oracle에서라면 다음 쿼리로 row를 생성할 수 있다.</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 1~100까지 숫자 생성 (100 rows)</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt;= <span class="number">100</span>;</div></pre></td></tr></table></figure><p>이렇게 row 생성 쿼리를 이용하면 테스트 데이터를 원하는 만큼 생성하는 것도 쉽고, 간단한 문제를 풀 때도 유용하다. 예를 들어 얼마 전 kldp.org에 올라왔던 1~45의 숫자 중 랜덤하게 6개를 선택해 표시하는 문제도 다음과 같이 SQL로 풀 수 있다.<br><a id="more"></a></p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 1~45의 숫자중 6개의 숫자를 랜덤하게 선택해 출력</span></div><div class="line"><span class="keyword">select</span> *</div><div class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> dual</div><div class="line">      <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt;=<span class="number">45</span></div><div class="line">      <span class="keyword">order</span> <span class="keyword">by</span> dbms_random.random)</div><div class="line"><span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">6</span>;</div></pre></td></tr></table></figure><p>그러나 이게 Oracle에서만 유효한 SQL이다보니 다른 DBMS에서는 활용할 수 없다. 요즘은 회사에서 사용하는PostgreSQL에서는 이 문제를 어떻게 해결할 수 있을까 고민했는데, 예상외로 쉬운 방법이 있었다. Oracle에서는 <code>connect by</code>를 이용한 재귀적 SQL을 사용했지만 PostgreSQL에서는 <code>generate_series()</code> 함수를 사용하면 된다.</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 1~100까지 숫자 생성 (100 rows)</span></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> generate_series(<span class="number">1</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 생성된 숫자를 이용한 계산이 필요할 때</span></div><div class="line"><span class="keyword">select</span> n, n*<span class="number">10</span> <span class="keyword">from</span> generate_series(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">as</span> t(n);</div></pre></td></tr></table></figure><p>따라서 1~45의 숫자 중 랜덤하게 6개를 선택해 표시하는 문제를 PostgreSQL에서는 다음과 같이 풀 수 있다.</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 1~45의 숫자중 6개의 숫자를 랜덤하게 선택해 출력</span></div><div class="line"><span class="keyword">select</span> *</div><div class="line"><span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> generate_series(<span class="number">1</span>, <span class="number">45</span>)</div><div class="line">      <span class="keyword">order</span> <span class="keyword">by</span> random()) <span class="keyword">as</span> t</div><div class="line"><span class="keyword">limit</span> <span class="number">6</span>;</div></pre></td></tr></table></figure><p>이와 비슷하게 데이터를 생성해내는 방법이 MySQL에도 있을까 찾아봤지만, 마음에 드는 방법을 찾지는 못했다. MySQL에서는 그냥 데이터가 많은 다른 테이블을 카테시안 조인해 데이터를 만들어내는 방법뿐인지, 아니면 다른 멋진 방법이 있는데 내가 알지 못하는 것인지 모르겠다.</p><div class="button-box"><a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a> <a class="twitter-follow-button" href="https://twitter.com/ntalbs" data-show-count="false">Follow @ntalbs</a></div></section><footer class="post-footer"><nav id="article-nav"><a href="/2009/wen-wan/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title">&#39;웬&#39;과 &#39;왠&#39;</span> </a><a href="/2009/credit-card/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">신용카드, 정말 재테크의 적인가?</span></a></nav><section id="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></footer></article></main><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><footer class="site-footer"><div class="inner"><section class="copyright">&copy; 2008-2018 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="http://hexo.io">Hexo</a></section></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script type="text/javascript" src="/js/jquery.fitvids.js"></script><script type="text/javascript" src="/js/index.js"></script><script>!function(e,a,t,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=a.createElement(t),o=a.getElementsByTagName(t)[0],s.async=1,s.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(s,o)}(window,document,"script",0,"ga"),ga("create","UA-2098194-3","auto"),ga("require","displayfeatures"),ga("send","pageview")</script><script type="text/javascript">var disqus_shortname="ntalbs-stuff";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config("");</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>