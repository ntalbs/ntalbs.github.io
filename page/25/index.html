<!DOCTYPE html><html><head><meta name="google-site-verification" content="U8HPz3to00q8wRxuKaw82QsuVvOzGyPxcWhySSYAjOE"><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>ntalbs&#39; stuff</title><meta name="description" content=""><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="ntalbs' stuff"></head><body class="home-template"><nav class="navbar" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-items">+</button> <a class="navbar-brand" href="/">@ntalbs' stuff</a></div><div class="navbar-items collapsed" id="nav-items"><ul><li><a href="/archives">Archives</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></div></div></nav><header class="site-head"><div class="container"><p class="blog-description">내 이 세상 도처에서 쉴 곳을 찾아보았으나, 마침내 찾아낸, 컴퓨터가 있는 구석방보다 나은 곳은 없더라.</p></div></header><main class="container" role="main"><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-28T00:00:00.000Z" itemprop="datePublished">2008-10-28</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/storing-dates/">날짜 데이터 저장</a></h1></header><section class="post-excerpt"><p></p><p>DBMS마다 날짜와 시간을 저장할 수 있는 데이터 타입을 제공한다. 그러나 날짜와 시간을 저장하는 데 <code>&#39;YYYYMMDD&#39;</code>, <code>&#39;HH24MISS&#39;</code> 형식의 문자열을 사용하는 경우도 많다. 인터넷 문서나 오래된 책을 찾아보면 날짜를 저장할 때 <code>DATE</code> 타입을 사용하지 말고 문자열로 저장하는 것이 좋다고 주장하는 경우도 흔하게 볼 수 있다. 날짜나 시간 데이터를 저장하는 데 문자열 데이터 타입을 사용하면 불필요하게 저장 공간이 늘어날 뿐 아니라 데이터 정합성이 떨어지고 성능에까지 영향을 미칠 수 있다. 이에 대해서 하나씩 살펴보자<br></p><p><a href="/2008/storing-dates/" class="excerpt-link">Read More...</a></p></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-28T00:00:00.000Z" itemprop="datePublished">2008-10-28</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/data-type/">올바른 데이터 타입 사용하기</a></h1></header><section class="post-excerpt"><p></p><p>데이터베이스에 테이블을 만들 때 각 컬럼의 데이터 타입을 정하는 것은 무척 쉬워 보인다. 데이터베이스에서 기본으로 제공하는 데이터 타입 종류가 엄청나게 많은 것도 아니고, 테이블에 저장할 데이터란 것도 대부분의 경우는 뻔하기 때문이다. 그러나 실제 데이터베이스를 보면 데이터 타입이 잘못 지정된 컬럼을 매우 자주 볼 수 있으며, 신규 테이블 생성을 요청할 때나 또는 컬럼 추가를 요청할 때도 데이터 타입을 잘못 지정해 요청하는 경우가 많다.<br></p><p><a href="/2008/data-type/" class="excerpt-link">Read More...</a></p></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-28T00:00:00.000Z" itemprop="datePublished">2008-10-28</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/partition-by-timestamp/">TIMESTAMP 컬럼으로 파티션 하는 방법</a></h1></header><section class="post-excerpt"><p></p><p>일반적으로 range 파티션 테이블을 만들 때는 다음과 같이 한다.<br></p><p><a href="/2008/partition-by-timestamp/" class="excerpt-link">Read More...</a></p></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-27T00:00:00.000Z" itemprop="datePublished">2008-10-27</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/direct-load-and-index/">다이렉트 로드와 인덱스</a></h1></header><section class="post-excerpt"><p></p><p>대량 데이터를 로드할 때 항상 궁금했던 것이 있다. 다음 두 가지 방법 중 어떤 것이 빠를까 하는 것이다.</p><ul><li>방법1: 인덱스가 있는 상태에서 그냥 다이렉트 모드로 로드</li><li>방법2: 인덱스를 날리고 로드한 다음 인덱스를 생성<p></p><p><a href="/2008/direct-load-and-index/" class="excerpt-link">Read More...</a></p></li></ul></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-27T00:00:00.000Z" itemprop="datePublished">2008-10-27</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/add-column-and-default-value/">컬럼 추가와 디폴트 값</a></h1></header><section class="post-excerpt"><p></p><p>기존 테이블에 컬럼을 추가할 때 디폴트 값을 지정하면 기존 데이터는 건드리지 않고 새로 추가되는 데이터에 대해서만 디폴드 값이 적용되는 줄 알고 있었다. 그런데 작업을 하다가 그동안 잘못 알고 있었다는 것을 알게 되었다. 다음 두 작업은 완전히 다르게 진행된다.<br></p><p><a href="/2008/add-column-and-default-value/" class="excerpt-link">Read More...</a></p></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-27T00:00:00.000Z" itemprop="datePublished">2008-10-27</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/direct-path-load/">Direct-path Insert시 주의사항</a></h1></header><section class="post-excerpt"><p></p><p>뭔가에 대해 어설프게 아는 것은 큰 위험을 초래할 수 있다. 이번에는 Direct-path Insert에 대한 어설픈 지식으로 큰 사고를 낼 뻔 했다. 지금까지 알고 있었던 사실은 Direct-path Insert를 이용하면 redo와 undo 로깅을 생략해 성능을 향상시킬 수 있다는 것이었다. 따라서 테이블에 대량의 데이터를 넣을 때 이 방법을 활용하곤 했다.</p><p><a href="/2008/direct-path-load/" class="excerpt-link">Read More...</a></p></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-24T23:00:00.000Z" itemprop="datePublished">2008-10-25</time> on <a href="/tags/리팩터링/" style="margin:0 5px">리팩터링</a></span><h1 class="post-title"><a href="/2008/refactoring/">코드 수정</a></h1></header><section class="post-excerpt"><p></p><p>소스코드를 보다가 다음과 같은 코드를 발견했다. 명령행 인수 분석해 딕셔너리에 넣는 코드인데, 이렇게 복잡할 필요가 있을까 생각되어 잠시 코드를 들여다 봤다.<br></p><p><a href="/2008/refactoring/" class="excerpt-link">Read More...</a></p></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-24T23:00:00.000Z" itemprop="datePublished">2008-10-25</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/records-per-block/">MINIMIZE RECORDS_PER_BLOCK</a></h1></header><section class="post-excerpt"><p></p><p>SQL Reference에 보면 <code>records_per_block</code>절에 대해 다음과 같이 설명되어 있다.</p><blockquote><p>instruct Oracle Database to calculate the largest number of records in any block in the table and to limit future inserts so that no block can contain more than that number of records.<br></p><p><a href="/2008/records-per-block/" class="excerpt-link">Read More...</a></p></blockquote></section></article><article class="post"><header class="post-header"><span class="post-meta"><time datetime="2008-10-23T23:00:00.000Z" itemprop="datePublished">2008-10-24</time> on <a href="/tags/DB/" style="margin:0 5px">DB</a><a href="/tags/Oracle/" style="margin:0 5px">Oracle</a></span><h1 class="post-title"><a href="/2008/dbms-job/">원하는 시간에만 DB 작업 실행하기</a></h1></header><section class="post-excerpt"><p></p><p>예전에 <a href="http://database.sarang.net/?criteria=oracle" target="_blank" rel="external">database.sarang.net 오라클 게시판</a>에 <code>DBMS_JOB</code>을 이용해 원하는 작업을 08시, 14시, 20시에 실행시키는 방법을 묻는 질문이 올라왔다. 작업 간격이 규칙적일 때는 문제가 간단하지만 원하는 시간 간격이 불규칙하므로 그냥 JOB을 세 개 등록하면 어떻겠냐고 답했더니 이번에는 이 작업을 평일에만 실행시키게 하고 싶다고 했다. 즉 평일 08시, 14시, 20시에 작업이 실행되도록 하고 싶다는 것이었다.<br></p><p><a href="/2008/dbms-job/" class="excerpt-link">Read More...</a></p></section></article><nav id="page-nav"><a class="extend prev" rel="prev" href="/page/24/">&lt; </a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span></nav></main><footer class="site-footer"><div class="inner"><section class="copyright">&copy; 2008-2015 <a href="/about">ntalbs</a></section><section class="poweredby">Powered by <a class="icon-ghost" href="http://hexo.io">Hexo</a></section></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script type="text/javascript" src="/js/jquery.fitvids.js"></script><script type="text/javascript" src="/js/index.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>!function(e,a,t,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=a.createElement(t),o=a.getElementsByTagName(t)[0],s.async=1,s.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(s,o)}(window,document,"script",0,"ga"),ga("create","UA-2098194-3","auto"),ga("require","displayfeatures"),ga("send","pageview")</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>